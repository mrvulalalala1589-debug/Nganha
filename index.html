<!DOCTYPE html>
<html lang="vi">
<head>
<meta charset="UTF-8">
<title>Awaken The Universe</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
html, body {
  width: 100%; height: 100%; overflow: hidden;
  background: #000; touch-action: none;
  font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
}
#hint {
  position: fixed; top: 50%; left: 50%;
  transform: translate(-50%, -50%);
  color: rgba(255, 230, 255, 0.95);
  font-size: 20px; text-align: center; z-index: 10;
  pointer-events: none;
  text-shadow: 0 0 30px rgba(255, 150, 255, 0.9), 0 0 60px rgba(150, 100, 255, 0.6);
  animation: pulse 3s ease-in-out infinite;
  transition: opacity 1s ease;
}
@keyframes pulse {
  0%, 100% { opacity: 0.8; transform: translate(-50%, -50%) scale(1); }
  50% { opacity: 1; transform: translate(-50%, -50%) scale(1.08); }
}
#backHint {
  position: fixed; bottom: 30px; left: 50%; transform: translateX(-50%);
  color: rgba(200, 230, 255, 0.8); font-size: 15px; text-align: center;
  z-index: 10; pointer-events: none; opacity: 0;
  text-shadow: 0 0 20px rgba(100, 200, 255, 0.8);
  transition: opacity 0.8s ease;
}
canvas { display: block; }
#loading {
  position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
  color: #fff; font-size: 18px; z-index: 5;
  text-shadow: 0 0 20px rgba(150, 200, 255, 0.8);
}
</style>
</head>
<body>

<div id="loading">‚ú® ƒêang t·∫£i v≈© tr·ª•...</div>
<div id="hint" style="opacity: 0;">üåå Ch·∫°m ƒë·ªÉ ƒë√°nh th·ª©c v≈© tr·ª• üåå</div>
<div id="backHint">üëÜ Click ph·∫£i ho·∫∑c n·∫Øm tay ƒë·ªÉ quay v·ªÅ üå†</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

<script>
const scene = new THREE.Scene();
scene.fog = new THREE.FogExp2(0x0a0520, 0.0003);

const camera = new THREE.PerspectiveCamera(75, innerWidth / innerHeight, 0.1, 5000);
camera.position.set(0, 20, 100);
camera.lookAt(0, 40, 0);

const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
renderer.setSize(innerWidth, innerHeight);
renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure = 1.4;
document.body.appendChild(renderer.domElement);

function createGlowTexture(innerColor, outerColor) {
  const canvas = document.createElement('canvas');
  canvas.width = canvas.height = 128;
  const ctx = canvas.getContext('2d');
  const gradient = ctx.createRadialGradient(64, 64, 0, 64, 64, 64);
  gradient.addColorStop(0, innerColor);
  gradient.addColorStop(0.15, outerColor);
  gradient.addColorStop(0.4, 'rgba(100, 100, 255, 0.2)');
  gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
  ctx.fillStyle = gradient;
  ctx.fillRect(0, 0, 128, 128);
  return new THREE.CanvasTexture(canvas);
}

function createCrossFlareTexture() {
  const canvas = document.createElement('canvas');
  canvas.width = canvas.height = 128;
  const ctx = canvas.getContext('2d');
  ctx.fillStyle = 'rgba(255, 255, 255, 0)';
  ctx.fillRect(0, 0, 128, 128);
  
  const hGrad = ctx.createLinearGradient(0, 64, 128, 64);
  hGrad.addColorStop(0, 'rgba(255, 255, 255, 0)');
  hGrad.addColorStop(0.5, 'rgba(255, 255, 255, 1)');
  hGrad.addColorStop(1, 'rgba(255, 255, 255, 0)');
  ctx.fillStyle = hGrad;
  ctx.fillRect(0, 60, 128, 8);
  
  const vGrad = ctx.createLinearGradient(64, 0, 64, 128);
  vGrad.addColorStop(0, 'rgba(255, 255, 255, 0)');
  vGrad.addColorStop(0.5, 'rgba(255, 255, 255, 1)');
  vGrad.addColorStop(1, 'rgba(255, 255, 255, 0)');
  ctx.fillStyle = vGrad;
  ctx.fillRect(60, 0, 8, 128);
  
  const cGrad = ctx.createRadialGradient(64, 64, 0, 64, 64, 30);
  cGrad.addColorStop(0, 'rgba(255, 255, 255, 1)');
  cGrad.addColorStop(1, 'rgba(255, 255, 255, 0)');
  ctx.fillStyle = cGrad;
  ctx.fillRect(34, 34, 60, 60);
  
  return new THREE.CanvasTexture(canvas);
}

const starGlowTex = createGlowTexture('rgba(255, 255, 255, 1)', 'rgba(180, 200, 255, 0.6)');
const warmGlowTex = createGlowTexture('rgba(255, 240, 200, 1)', 'rgba(255, 180, 120, 0.7)');
const crossFlareTex = createCrossFlareTexture();
const bokehTex = createGlowTexture('rgba(255, 200, 255, 0.8)', 'rgba(150, 150, 255, 0.3)');

const skyGeo = new THREE.SphereGeometry(2000, 32, 32);
const skyMat = new THREE.ShaderMaterial({
  uniforms: {
    topColor: { value: new THREE.Color(0x0a0520) },
    bottomColor: { value: new THREE.Color(0x4a2860) },
    horizonColor: { value: new THREE.Color(0xff8866) },
    offset: { value: 20 },
    exponent: { value: 0.6 }
  },
  vertexShader: `
    varying vec3 vWorldPosition;
    void main() {
      vec4 worldPosition = modelMatrix * vec4(position, 1.0);
      vWorldPosition = worldPosition.xyz;
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    }
  `,
  fragmentShader: `
    uniform vec3 topColor;
    uniform vec3 bottomColor;
    uniform vec3 horizonColor;
    uniform float offset;
    uniform float exponent;
    varying vec3 vWorldPosition;
    void main() {
      float h = normalize(vWorldPosition + offset).y;
      float t = max(pow(max(h, 0.0), exponent), 0.0);
      vec3 skyColor = mix(bottomColor, topColor, t);
      float horizonGlow = exp(-abs(h) * 3.0) * 0.5;
      skyColor = mix(skyColor, horizonColor, horizonGlow);
      gl_FragColor = vec4(skyColor, 1.0);
    }
  `,
  side: THREE.BackSide
});
const sky = new THREE.Mesh(skyGeo, skyMat);
scene.add(sky);

function createStarfield(count, spread, yRange, sizeRange, useFlare) {
  const geometry = new THREE.BufferGeometry();
  const positions = new Float32Array(count * 3);
  const sizes = new Float32Array(count);
  const colors = new Float32Array(count * 3);
  const alphas = new Float32Array(count);
  
  for (let i = 0; i < count; i++) {
    const theta = Math.random() * Math.PI * 2;
    const r = Math.sqrt(Math.random()) * spread;
    positions[i * 3] = Math.cos(theta) * r;
    positions[i * 3 + 1] = (Math.random() - 0.3) * yRange;
    positions[i * 3 + 2] = Math.sin(theta) * r;
    
    sizes[i] = sizeRange[0] + Math.random() * (sizeRange[1] - sizeRange[0]);
    alphas[i] = 0.4 + Math.random() * 0.6;
    
    const colorChoice = Math.random();
    if (colorChoice > 0.9) {
      colors[i * 3] = 1.0; colors[i * 3 + 1] = 0.9; colors[i * 3 + 2] = 0.8;
    } else if (colorChoice > 0.7) {
      colors[i * 3] = 0.8; colors[i * 3 + 1] = 0.9; colors[i * 3 + 2] = 1.0;
    } else {
      colors[i * 3] = 1.0; colors[i * 3 + 1] = 1.0; colors[i * 3 + 2] = 1.0;
    }
  }
  
  geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
  geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
  geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
  geometry.setAttribute('alpha', new THREE.BufferAttribute(alphas, 1));
  
  const material = new THREE.ShaderMaterial({
    uniforms: {
      pointTexture: { value: useFlare ? crossFlareTex : starGlowTex },
      time: { value: 0 }
    },
    vertexShader: `
      attribute float size;
      attribute float alpha;
      attribute vec3 color;
      varying float vAlpha;
      varying vec3 vColor;
      uniform float time;
      void main() {
        vAlpha = alpha * (0.6 + 0.4 * sin(time * 1.5 + position.x * 0.01 + position.z * 0.01));
        vColor = color;
        vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
        gl_PointSize = size * (350.0 / -mvPosition.z);
        gl_Position = projectionMatrix * mvPosition;
      }
    `,
    fragmentShader: `
      uniform sampler2D pointTexture;
      varying float vAlpha;
      varying vec3 vColor;
      void main() {
        vec4 texColor = texture2D(pointTexture, gl_PointCoord);
        gl_FragColor = vec4(vColor * texColor.rgb, texColor.a * vAlpha);
      }
    `,
    blending: THREE.AdditiveBlending,
    depthWrite: false,
    transparent: true,
    vertexColors: true
  });
  
  return new THREE.Points(geometry, material);
}

const bgStars = createStarfield(5000, 2200, 1000, [2, 4], false);
scene.add(bgStars);
const fgStars = createStarfield(1500, 1500, 600, [4, 8], false);
scene.add(fgStars);
const brightStars = createStarfield(200, 1800, 700, [12, 20], true);
scene.add(brightStars);

function createBokehParticles() {
  const geometry = new THREE.BufferGeometry();
  const count = 300;
  const positions = new Float32Array(count * 3);
  const sizes = new Float32Array(count);
  const colors = new Float32Array(count * 3);
  
  const bokehColors = [[1.0, 0.8, 1.0], [0.8, 0.9, 1.0], [1.0, 0.9, 0.8], [0.9, 0.8, 1.0]];
  
  for (let i = 0; i < count; i++) {
    const theta = Math.random() * Math.PI * 2;
    const r = 300 + Math.random() * 800;
    positions[i * 3] = Math.cos(theta) * r;
    positions[i * 3 + 1] = -50 + Math.random() * 400;
    positions[i * 3 + 2] = Math.sin(theta) * r - 200;
    sizes[i] = 15 + Math.random() * 40;
    
    const color = bokehColors[Math.floor(Math.random() * bokehColors.length)];
    colors[i * 3] = color[0];
    colors[i * 3 + 1] = color[1];
    colors[i * 3 + 2] = color[2];
  }
  
  geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
  geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
  geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
  
  const material = new THREE.PointsMaterial({
    size: 30, map: bokehTex, transparent: true, opacity: 0.4,
    blending: THREE.AdditiveBlending, vertexColors: true, depthWrite: false
  });
  
  return new THREE.Points(geometry, material);
}
const bokehParticles = createBokehParticles();
scene.add(bokehParticles);

function createNebulaCloud(color, posY, posZ, size) {
  const geometry = new THREE.BufferGeometry();
  const count = 400;
  const positions = new Float32Array(count * 3);
  const sizes = new Float32Array(count);
  
  for (let i = 0; i < count; i++) {
    positions[i * 3] = (Math.random() - 0.5) * size;
    positions[i * 3 + 1] = posY + (Math.random() - 0.5) * 80;
    positions[i * 3 + 2] = posZ + (Math.random() - 0.5) * 200;
    sizes[i] = 60 + Math.random() * 100;
  }
  
  geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
  geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
  
  const material = new THREE.PointsMaterial({
    size: 100, map: starGlowTex, color: color, transparent: true,
    opacity: 0.12, blending: THREE.AdditiveBlending, depthWrite: false
  });
  
  return new THREE.Points(geometry, material);
}

const nebulaClouds = [];
nebulaClouds.push(createNebulaCloud(0x6644ff, 80, -400, 1200));
nebulaClouds.push(createNebulaCloud(0xff66aa, 60, -500, 1000));
nebulaClouds.push(createNebulaCloud(0x44aaff, 100, -350, 1100));
nebulaClouds.forEach(cloud => scene.add(cloud));

const meteors = [];
function createMeteor() {
  const group = new THREE.Group();
  
  const trailLength = 80;
  const geometry = new THREE.BufferGeometry();
  const positions = new Float32Array(trailLength * 3);
  const colors = new Float32Array(trailLength * 3);
  
  for (let i = 0; i < trailLength; i++) {
    const t = i / trailLength;
    positions[i * 3] = t * 50;
    positions[i * 3 + 1] = t * 18;
    positions[i * 3 + 2] = t * 100;
    
    const intensity = 1 - t;
    colors[i * 3] = 1.0 * intensity;
    colors[i * 3 + 1] = 0.85 * intensity;
    colors[i * 3 + 2] = 0.65 * intensity;
  }
  
  geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
  geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
  
  const trail = new THREE.Line(geometry, new THREE.LineBasicMaterial({
    vertexColors: true, linewidth: 3, transparent: true, opacity: 0.95, blending: THREE.AdditiveBlending
  }));
  group.add(trail);
  
  const coreMat = new THREE.SpriteMaterial({
    map: warmGlowTex, color: 0xffeeaa, blending: THREE.AdditiveBlending, transparent: true
  });
  const coreSprite = new THREE.Sprite(coreMat);
  coreSprite.scale.set(12, 12, 1);
  group.add(coreSprite);
  
  const particleGeo = new THREE.BufferGeometry();
  const particleCount = 30;
  const particlePos = new Float32Array(particleCount * 3);
  const particleSizes = new Float32Array(particleCount);
  
  for (let i = 0; i < particleCount; i++) {
    const t = i / particleCount;
    particlePos[i * 3] = t * 45 + (Math.random() - 0.5) * 4;
    particlePos[i * 3 + 1] = t * 16 + (Math.random() - 0.5) * 4;
    particlePos[i * 3 + 2] = t * 90 + (Math.random() - 0.5) * 8;
    particleSizes[i] = (1 - t) * 3;
  }
  
  particleGeo.setAttribute('position', new THREE.BufferAttribute(particlePos, 3));
  particleGeo.setAttribute('size', new THREE.BufferAttribute(particleSizes, 1));
  
  const particleMat = new THREE.PointsMaterial({
    size: 4, map: starGlowTex, color: 0xffdd88, transparent: true,
    blending: THREE.AdditiveBlending, depthWrite: false
  });
  
  const particles = new THREE.Points(particleGeo, particleMat);
  group.add(particles);
  
  group.position.set(Math.random() * 700 - 350, 180 + Math.random() * 250, -450 - Math.random() * 250);
  group.userData.speed = 0.9 + Math.random() * 1.4;
  group.userData.direction = new THREE.Vector3(-1.6, -0.9, -2.2).normalize();
  
  scene.add(group);
  meteors.push(group);
}
for (let i = 0; i < 15; i++) createMeteor();

const atmosphericClouds = [];
for (let i = 0; i < 5; i++) {
  const geometry = new THREE.PlaneGeometry(1600, 450, 25, 25);
  const positions = geometry.attributes.position;
  
  for (let j = 0; j < positions.count; j++) {
    const wave = Math.sin(j * 0.2) * Math.cos(j * 0.15);
    positions.setZ(j, wave * 20 * Math.random());
  }
  
  const hue = 0.7 + i * 0.02;
  const material = new THREE.MeshBasicMaterial({
    color: new THREE.Color().setHSL(hue, 0.5, 0.15 + i * 0.03),
    transparent: true, opacity: 0.06, side: THREE.DoubleSide, blending: THREE.AdditiveBlending
  });
  
  const cloud = new THREE.Mesh(geometry, material);
  cloud.position.set((Math.random() - 0.5) * 200, 45 + i * 30, -450 - i * 110);
  cloud.rotation.x = -0.15;
  scene.add(cloud);
  atmosphericClouds.push(cloud);
}

const groundGeo = new THREE.PlaneGeometry(2500, 800);
const groundMat = new THREE.MeshBasicMaterial({ color: 0x050510, transparent: true, opacity: 0.9 });
const ground = new THREE.Mesh(groundGeo, groundMat);
ground.position.set(0, -120, -250);
ground.rotation.x = -Math.PI / 2;
scene.add(ground);

const horizonGeo = new THREE.PlaneGeometry(2500, 250);
const horizonMat = new THREE.MeshBasicMaterial({
  color: 0x3a1560, transparent: true, opacity: 0.4, side: THREE.DoubleSide
});
const horizon = new THREE.Mesh(horizonGeo, horizonMat);
horizon.position.set(0, 10, -600);
scene.add(horizon);

let awakened = false, transitioning = false;
const galaxy = new THREE.Group();
galaxy.visible = false;
scene.add(galaxy);

function createGalaxyNebula() {
  const geometry = new THREE.BufferGeometry();
  const count = 2000;
  const positions = new Float32Array(count * 3);
  const colors = new Float32Array(count * 3);
  const sizes = new Float32Array(count);
  
  const nebulaColors = [[0.3, 0.5, 1.0], [0.8, 0.3, 1.0], [1.0, 0.4, 0.8], [0.4, 0.8, 1.0]];
  
  for (let i = 0; i < count; i++) {
    const theta = Math.random() * Math.PI * 2;
    const phi = Math.acos(2 * Math.random() - 1);
    const r = 50 + Math.random() * 200;
    
    positions[i * 3] = r * Math.sin(phi) * Math.cos(theta);
    positions[i * 3 + 1] = (Math.random() - 0.5) * 100;
    positions[i * 3 + 2] = r * Math.sin(phi) * Math.sin(theta);
    
    const color = nebulaColors[Math.floor(Math.random() * nebulaColors.length)];
    colors[i * 3] = color[0]; colors[i * 3 + 1] = color[1]; colors[i * 3 + 2] = color[2];
    sizes[i] = 40 + Math.random() * 120;
  }
  
  geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
  geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
  geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
  
  const material = new THREE.PointsMaterial({
    size: 80, map: starGlowTex, vertexColors: true, blending: THREE.AdditiveBlending,
    transparent: true, opacity: 0.25, depthWrite: false
  });
  
  return new THREE.Points(geometry, material);
}
const galaxyNebula = createGalaxyNebula();
galaxy.add(galaxyNebula);

function createGalaxySpiral() {
  const geometry = new THREE.BufferGeometry();
  const count = 15000;
  const positions = new Float32Array(count * 3);
  const colors = new Float32Array(count * 3);
  const sizes = new Float32Array(count);
  
  for (let i = 0; i < count; i++) {
    const armIndex = Math.floor(Math.random() * 4);
    const armAngle = (armIndex * Math.PI * 2) / 4;
    const t = Math.random();
    const radius = 15 + t * 160;
    const spinAngle = radius * 0.09;
    const angle = armAngle + spinAngle;
    
    const x = Math.cos(angle) * radius + (Math.random() - 0.5) * 10;
    const y = (Math.random() - 0.5) * 18 * (1 - t * 0.6);
    const z = Math.sin(angle) * radius + (Math.random() - 0.5) * 10;
    
    positions[i * 3] = x; positions[i * 3 + 1] = y; positions[i * 3 + 2] = z;
    
    const coreDistance = radius / 160;
    const coreBrightness = 1 - coreDistance;
    
    colors[i * 3] = 0.9 + coreBrightness * 0.1;
    colors[i * 3 + 1] = 0.8 + Math.random() * 0.2 - coreDistance * 0.3;
    colors[i * 3 + 2] = 0.7 + coreDistance * 0.3;
    sizes[i] = 2.5 + (1 - coreDistance) * 4;
  }
  
  geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
  geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
  geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
  
  const material = new THREE.PointsMaterial({
    size: 3.5, map: starGlowTex, vertexColors: true,
    blending: THREE.AdditiveBlending, transparent: true, depthWrite: false
  });
  
  return new THREE.Points(geometry, material);
}
const spiral = createGalaxySpiral();
galaxy.add(spiral);

const coreGeo = new THREE.SphereGeometry(12, 32, 32);
const coreMat = new THREE.MeshBasicMaterial({ color: 0xffffee, transparent: true, opacity: 0.9 });
const core = new THREE.Mesh(coreGeo, coreMat);
galaxy.add(core);

for (let i = 0; i < 3; i++) {
  const glowSprite = new THREE.Sprite(new THREE.SpriteMaterial({
    map: warmGlowTex,
    color: i === 0 ? 0xffffee : i === 1 ? 0xffccee : 0xaaccff,
    blending: THREE.AdditiveBlending, transparent: true, opacity: 0.7 - i * 0.2
  }));
  glowSprite.scale.set(80 + i * 40, 80 + i * 40, 1);
  galaxy.add(glowSprite);
}

const images = [];
const imgUrls = [];
for (let i = 1; i <= 10; i++) imgUrls.push(`space${i}.png`);

const loader = new THREE.TextureLoader();
let loadedCount = 0;

imgUrls.forEach((url, i) => {
  loader.load(url, (texture) => {
    const aspect = texture.image.width / texture.image.height;
    const mesh = new THREE.Mesh(
      new THREE.PlaneGeometry(22 * aspect, 22),
      new THREE.MeshBasicMaterial({ map: texture, transparent: true, opacity: 0, side: THREE.DoubleSide })
    );
    
    const glowBorder = new THREE.Sprite(new THREE.SpriteMaterial({
      map: bokehTex, color: 0xaaccff, blending: THREE.AdditiveBlending, transparent: true, opacity: 0
    }));
    glowBorder.scale.set(24 * aspect, 24, 1);
    mesh.add(glowBorder);
    
    mesh.userData = {
      angle: (i / imgUrls.length) * Math.PI * 2,
      radius: 65 + (i % 3) * 18,
      speed: 0.0007 + Math.random() * 0.0005,
      yOffset: Math.sin(i) * 22,
      glow: glowBorder
    };
    
    galaxy.add(mesh);
    images.push(mesh);
    
    loadedCount++;
    if (loadedCount === imgUrls.length) {
      document.getElementById('loading').style.display = 'none';
      document.getElementById('hint').style.opacity = 1;
    }
  }, undefined, () => {
    loadedCount++;
    if (loadedCount === imgUrls.length) {
      document.getElementById('loading').style.display = 'none';
      document.getElementById('hint').style.opacity = 1;
    }
  });
});

const ambientLight = new THREE.AmbientLight(0x5577aa, 0.35);
scene.add(ambientLight);
const pointLight = new THREE.PointLight(0xaabbff, 1.6, 1200);
pointLight.position.set(0, 180, 350);
scene.add(pointLight);
const galaxyLight = new THREE.PointLight(0xffeecc, 2.5, 250);
galaxyLight.visible = false;
galaxy.add(galaxyLight);

function transitionToGalaxy() {
  if (awakened || transitioning) return;
  transitioning = true; awakened = true;
  document.getElementById('hint').style.opacity = 0;
  
  const startPos = camera.position.clone();
  const startLookAt = new THREE.Vector3(0, 40, 0);
  const endPos = new THREE.Vector3(0, 0, 220);
 const endLookAt = new THREE.Vector3(0, 0, 0);
const duration = 2600;
const startTime = performance.now();

galaxy.visible = true;
galaxyLight.visible = true;

function animateTransition(now) {
  const t = Math.min((now - startTime) / duration, 1);
  const ease = t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2;

  camera.position.lerpVectors(startPos, endPos, ease);
  const lookAt = startLookAt.clone().lerp(endLookAt, ease);
  camera.lookAt(lookAt);

  sky.material.opacity = 1 - ease;
  bgStars.material.uniforms.time.value += 0.01;
  fgStars.material.uniforms.time.value += 0.015;
  brightStars.material.uniforms.time.value += 0.02;

  if (t < 1) {
    requestAnimationFrame(animateTransition);
  } else {
    transitioning = false;
    document.getElementById('backHint').style.opacity = 1;
  }
}
requestAnimationFrame(animateTransition);
}

/* ====== INTERACTION (tap / gi·ªØ / k√©o / xoay) ====== */
let isDragging = false;
let lastX = 0, lastY = 0;
let rotationSpeed = { x: 0, y: 0 };

renderer.domElement.addEventListener('pointerdown', e => {
  if (!awakened) {
    transitionToGalaxy();
    return;
  }
  isDragging = true;
  lastX = e.clientX;
  lastY = e.clientY;
});

renderer.domElement.addEventListener('pointermove', e => {
  if (!isDragging) return;
  const dx = e.clientX - lastX;
  const dy = e.clientY - lastY;
  rotationSpeed.y = dx * 0.0006;
  rotationSpeed.x = dy * 0.0006;
  lastX = e.clientX;
  lastY = e.clientY;
});

renderer.domElement.addEventListener('pointerup', () => {
  isDragging = false;
});

renderer.domElement.addEventListener('contextmenu', e => {
  e.preventDefault();
  awakened = false;
  galaxy.visible = false;
  galaxyLight.visible = false;
  document.getElementById('hint').style.opacity = 1;
  document.getElementById('backHint').style.opacity = 0;
  camera.position.set(0, 20, 100);
  camera.lookAt(0, 40, 0);
});

/* ====== MAIN ANIMATION LOOP ====== */
function animate() {
  requestAnimationFrame(animate);

  bgStars.material.uniforms.time.value += 0.003;
  fgStars.material.uniforms.time.value += 0.004;
  brightStars.material.uniforms.time.value += 0.005;

  meteors.forEach(m => {
    m.position.addScaledVector(m.userData.direction, m.userData.speed);
    if (m.position.z < -1200) {
      m.position.set(Math.random() * 700 - 350, 200 + Math.random() * 250, -300);
    }
  });

  atmosphericClouds.forEach((c, i) => {
    c.position.x += Math.sin(performance.now() * 0.0002 + i) * 0.02;
  });

  if (galaxy.visible) {
    galaxy.rotation.y += rotationSpeed.y;
    galaxy.rotation.x += rotationSpeed.x;
    rotationSpeed.x *= 0.92;
    rotationSpeed.y *= 0.92;

    images.forEach((img, i) => {
      const d = img.userData;
      d.angle += d.speed;
      img.position.set(
        Math.cos(d.angle) * d.radius,
        d.yOffset + Math.sin(d.angle * 2) * 6,
        Math.sin(d.angle) * d.radius
      );

      img.material.opacity = Math.min(img.material.opacity + 0.01, 1);
      d.glow.material.opacity = img.material.opacity * 0.6;
      img.lookAt(camera.position);
    });
  }

  renderer.render(scene, camera);
}
animate();

/* ====== RESIZE ====== */
window.addEventListener('resize', () => {
  camera.aspect = innerWidth / innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
});
</script>
</body>
</html>
