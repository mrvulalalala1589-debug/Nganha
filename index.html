<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Galaxy Adventure - Phi√™u L∆∞u V≈© Tr·ª•</title>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Space+Mono:wght@400;700&display=swap');
        
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body { 
            margin: 0; 
            overflow: hidden; 
            background: radial-gradient(ellipse at center, #0a0a1a 0%, #000000 100%);
            font-family: 'Space Mono', monospace;
            cursor: none;
        }

        /* Custom Cursor */
        #custom-cursor {
            position: fixed;
            width: 30px;
            height: 30px;
            border: 2px solid rgba(0, 255, 255, 0.6);
            border-radius: 50%;
            pointer-events: none;
            z-index: 10000;
            transition: transform 0.1s ease;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.4),
                        inset 0 0 10px rgba(0, 255, 255, 0.2);
        }
        
        #custom-cursor::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 6px;
            height: 6px;
            background: #00ffff;
            border-radius: 50%;
            box-shadow: 0 0 10px #00ffff;
        }

        #canvas-container { 
            width: 100%; 
            height: 100vh; 
            display: block; 
            position: relative;
        }
        
        /* Splash Screen */
        #splash-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100vh;
            background: radial-gradient(ellipse at center, #1a1a3a 0%, #000000 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            transition: opacity 1s ease-out;
        }

        #splash-screen.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .splash-title {
            font-family: 'Orbitron', sans-serif;
            font-size: clamp(3rem, 10vw, 8rem);
            font-weight: 900;
            background: linear-gradient(45deg, #00ffff, #ff00ff, #ffff00, #00ffff);
            background-size: 300% 300%;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-align: center;
            animation: gradientShift 3s ease infinite, floatTitle 3s ease-in-out infinite;
            text-shadow: 0 0 80px rgba(0, 255, 255, 0.5);
            letter-spacing: 0.1em;
            margin-bottom: 2rem;
        }

        @keyframes gradientShift {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }

        @keyframes floatTitle {
            0%, 100% { transform: translateY(0px); }
            50% { transform: translateY(-20px); }
        }

        .splash-subtitle {
            font-family: 'Space Mono', monospace;
            font-size: clamp(1rem, 3vw, 1.5rem);
            color: rgba(0, 255, 255, 0.7);
            text-align: center;
            margin-bottom: 4rem;
            letter-spacing: 0.2em;
            animation: pulse 2s ease-in-out infinite;
        }

        #start-button {
            position: relative;
            padding: 20px 60px;
            font-family: 'Orbitron', sans-serif;
            font-size: 1.5rem;
            font-weight: 700;
            color: #00ffff;
            background: transparent;
            border: 3px solid #00ffff;
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 0.2em;
            overflow: hidden;
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.3),
                        inset 0 0 30px rgba(0, 255, 255, 0.1);
            animation: pulseButton 2s ease-in-out infinite;
        }

        #start-button::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            border-radius: 50%;
            background: rgba(0, 255, 255, 0.2);
            transform: translate(-50%, -50%);
            transition: width 0.6s ease, height 0.6s ease;
        }

        #start-button:hover::before {
            width: 300px;
            height: 300px;
        }

        #start-button:hover {
            background: rgba(0, 255, 255, 0.1);
            box-shadow: 0 0 50px rgba(0, 255, 255, 0.6),
                        inset 0 0 50px rgba(0, 255, 255, 0.2);
            transform: scale(1.1);
        }

        @keyframes pulseButton {
            0%, 100% { box-shadow: 0 0 30px rgba(0, 255, 255, 0.3), inset 0 0 30px rgba(0, 255, 255, 0.1); }
            50% { box-shadow: 0 0 60px rgba(0, 255, 255, 0.6), inset 0 0 50px rgba(0, 255, 255, 0.3); }
        }

        /* UI Layer */
        #ui-layer {
            position: absolute;
            bottom: 40px;
            width: 100%;
            text-align: center;
            pointer-events: none;
            z-index: 100;
        }
        
        #status-badge {
            display: inline-block;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid rgba(0, 255, 255, 0.6);
            color: #00ffff;
            padding: 15px 40px;
            border-radius: 50px;
            font-size: 1.2rem;
            font-weight: 700;
            font-family: 'Orbitron', sans-serif;
            text-transform: uppercase;
            letter-spacing: 0.15em;
            box-shadow: 0 0 40px rgba(0, 255, 255, 0.4),
                        inset 0 0 20px rgba(0, 255, 255, 0.1);
            text-shadow: 0 0 20px #00ffff;
            animation: statusGlow 2s ease-in-out infinite;
        }

        @keyframes statusGlow {
            0%, 100% { 
                box-shadow: 0 0 40px rgba(0, 255, 255, 0.4), inset 0 0 20px rgba(0, 255, 255, 0.1);
                border-color: rgba(0, 255, 255, 0.6);
            }
            50% { 
                box-shadow: 0 0 60px rgba(0, 255, 255, 0.7), inset 0 0 30px rgba(0, 255, 255, 0.2);
                border-color: rgba(0, 255, 255, 1);
            }
        }

        .gesture-guide {
            color: rgba(255, 255, 255, 0.6);
            font-size: 0.9rem;
            margin-top: 15px;
            text-shadow: 0 2px 10px rgba(0, 0, 0, 0.8);
            letter-spacing: 0.05em;
        }

        .gesture-guide span {
            color: #00ffff;
            font-weight: 700;
        }

        /* Camera Preview */
        #camera-container {
            position: absolute;
            top: 20px;
            right: 20px;
            transition: all 0.5s ease;
            z-index: 200;
        }

        #camera-container.minimized {
            width: 160px;
            height: 120px;
        }

        #camera-container.expanded {
            width: 400px;
            height: 300px;
        }

        #camera-preview {
            width: 100%;
            height: 100%;
            border: 3px solid rgba(0, 255, 255, 0.6);
            transform: scaleX(-1);
            border-radius: 12px;
            box-shadow: 0 0 40px rgba(0, 255, 255, 0.5);
            background: rgba(0, 0, 0, 0.8);
        }

        #camera-toggle {
            position: absolute;
            bottom: -40px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid rgba(0, 255, 255, 0.6);
            color: #00ffff;
            padding: 8px 20px;
            border-radius: 20px;
            cursor: pointer;
            font-family: 'Space Mono', monospace;
            font-size: 0.8rem;
            transition: all 0.3s ease;
            pointer-events: auto;
        }

        #camera-toggle:hover {
            background: rgba(0, 255, 255, 0.2);
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
        }

        #camera-status {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.8);
            color: #00ff00;
            padding: 5px 15px;
            border-radius: 15px;
            font-family: 'Space Mono', monospace;
            font-size: 0.75rem;
            border: 1px solid rgba(0, 255, 0, 0.5);
        }

        #camera-status.detecting {
            color: #00ff00;
            border-color: rgba(0, 255, 0, 0.8);
            animation: detectPulse 1s ease-in-out infinite;
        }

        #camera-status.no-hand {
            color: #ff9900;
            border-color: rgba(255, 153, 0, 0.5);
        }

        @keyframes detectPulse {
            0%, 100% { box-shadow: 0 0 10px rgba(0, 255, 0, 0.3); }
            50% { box-shadow: 0 0 20px rgba(0, 255, 0, 0.6); }
        }

        /* Photo Counter */
        #photo-counter {
            position: absolute;
            top: 30px;
            left: 50%;
            transform: translateX(-50%);
            font-family: 'Orbitron', sans-serif;
            font-size: 1.5rem;
            color: #00ffff;
            text-shadow: 0 0 20px rgba(0, 255, 255, 0.8);
            letter-spacing: 0.2em;
            opacity: 0;
            transition: opacity 0.5s ease;
        }

        #photo-counter.visible {
            opacity: 1;
        }

        /* Swipe Indicator */
        #swipe-indicator {
            position: absolute;
            bottom: 120px;
            left: 50%;
            transform: translateX(-50%);
            font-family: 'Space Mono', monospace;
            font-size: 1rem;
            color: rgba(255, 255, 255, 0.7);
            text-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
            opacity: 0;
            transition: opacity 0.5s ease;
            animation: swipeHint 2s ease-in-out infinite;
        }

        #swipe-indicator.visible {
            opacity: 1;
        }

        @keyframes swipeHint {
            0%, 100% { transform: translateX(-50%) translateY(0); }
            50% { transform: translateX(-50%) translateY(-10px); }
        }

        /* Loading Animation */
        .loading-dots {
            display: inline-block;
            margin-left: 10px;
        }

        .loading-dots span {
            display: inline-block;
            animation: loadingDot 1.4s infinite ease-in-out both;
        }

        .loading-dots span:nth-child(1) { animation-delay: -0.32s; }
        .loading-dots span:nth-child(2) { animation-delay: -0.16s; }

        @keyframes loadingDot {
            0%, 80%, 100% { opacity: 0; }
            40% { opacity: 1; }
        }

        /* Error/Info Messages */
        #message-box {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid #ff0066;
            color: #ff0066;
            padding: 30px 50px;
            border-radius: 20px;
            font-family: 'Space Mono', monospace;
            text-align: center;
            display: none;
            z-index: 999;
            box-shadow: 0 0 50px rgba(255, 0, 102, 0.5);
        }

        #message-box.visible {
            display: block;
            animation: fadeIn 0.5s ease;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
            to { opacity: 1; transform: translate(-50%, -50%) scale(1); }
        }

        .video-container {
            display: none;
        }
    </style>
</head>
<body>
    <!-- Custom Cursor -->
    <div id="custom-cursor"></div>

    <!-- Splash Screen -->
    <div id="splash-screen">
        <div class="splash-title">GALAXY</div>
        <div class="splash-subtitle">KH√ÅM PH√Å V≈® TR·ª§</div>
        <button id="start-button">
            <span>CH·∫†M ƒê·ªÇ PHI√äU L∆ØU</span>
        </button>
    </div>

    <!-- Message Box -->
    <div id="message-box"></div>

    <!-- Main UI -->
    <div id="ui-layer" style="display: none;">
        <div id="status-badge">üåå KH√ÅM PH√Å V≈® TR·ª§ üåå</div>
        <div class="gesture-guide">
            <span>‚úä N·∫ÆM TAY:</span> Thu Galaxy &nbsp;|&nbsp; 
            <span>üñê X√íE TAY:</span> Bung H√†nh Tinh &nbsp;|&nbsp; 
            <span>üëâ PH·∫§T TAY:</span> L∆∞·ªõt ·∫¢nh
        </div>
    </div>

    <!-- Photo Counter -->
    <div id="photo-counter">1 / 10</div>

    <!-- Swipe Indicator -->
    <div id="swipe-indicator">‚Üê PH·∫§T TAY ƒê·ªÇ L∆Ø·ªöT ·∫¢NH ‚Üí</div>

    <!-- Camera Container with Toggle -->
    <div id="camera-container" class="minimized">
        <canvas id="camera-preview"></canvas>
        <div id="camera-status" class="no-hand">ƒêang t√¨m tay...</div>
        <button id="camera-toggle" onclick="toggleCamera()">üìπ M·ªû R·ªòNG</button>
    </div>

    <!-- Canvas Container -->
    <div id="canvas-container"></div>

    <!-- Video Elements -->
    <div class="video-container">
        <video class="input_video"></video>
    </div>

    <script>
        // ==========================================
        // CONFIGURATION
        // ==========================================
        const CONFIG = {
            // Galaxy Core
            coreParticles: 30000,
            diskParticles: 70000,
            
            // Stars
            starCount: 5000,
            
            // Planets
            planetCount: 50,
            
            // Photos
            photoCount: 10,
            photoOrbitRadius: 30,
            
            // States
            explodeRadius: 70,
            galaxyRadius: 50,
            
            // Animation
            rotationSpeed: 0.001,
            swipeThreshold: 0.15
        };

        const MUSIC_URL = "./audio.mp3";
        let bgMusic = new Audio(MUSIC_URL);
        bgMusic.loop = true;
        bgMusic.volume = 0.6;

        // Photo files
        const photoFiles = [];
        for(let i = 1; i <= CONFIG.photoCount; i++) {
            photoFiles.push(`./image${i}.png`);
        }

        // ==========================================
        // GLOBAL VARIABLES
        // ==========================================
        let scene, camera, renderer;
        let galaxyCore, galaxyDisk, starField;
        let planets = [];
        let photoMeshes = [];
        let nebulaParticles;
        
        let state = 'GALAXY'; // GALAXY, EXPLODE, PHOTO
        let currentPhotoIndex = 0;
        let handX = 0.5;
        let prevHandX = 0.5;
        let swipeVelocity = 0;

        // ==========================================
        // TEXTURE CREATION
        // ==========================================
        function createGlowTexture(color1, color2) {
            const canvas = document.createElement('canvas');
            canvas.width = 128;
            canvas.height = 128;
            const ctx = canvas.getContext('2d');
            const cx = 64, cy = 64;

            const grd = ctx.createRadialGradient(cx, cy, 0, cx, cy, 64);
            grd.addColorStop(0, color1);
            grd.addColorStop(0.3, color2);
            grd.addColorStop(1, 'rgba(0,0,0,0)');
            ctx.fillStyle = grd;
            ctx.fillRect(0, 0, 128, 128);

            return new THREE.CanvasTexture(canvas);
        }

        function createStarTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 64;
            canvas.height = 64;
            const ctx = canvas.getContext('2d');
            const cx = 32, cy = 32;

            // Glow
            const grd = ctx.createRadialGradient(cx, cy, 0, cx, cy, 32);
            grd.addColorStop(0, '#FFFFFF');
            grd.addColorStop(0.1, '#FFFFAA');
            grd.addColorStop(1, 'rgba(0,0,0,0)');
            ctx.fillStyle = grd;
            ctx.fillRect(0, 0, 64, 64);

            // Cross sparkle
            ctx.strokeStyle = 'rgba(255,255,255,0.8)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(cx - 15, cy);
            ctx.lineTo(cx + 15, cy);
            ctx.moveTo(cx, cy - 15);
            ctx.lineTo(cx, cy + 15);
            ctx.stroke();

            return new THREE.CanvasTexture(canvas);
        }

        function createPlanetTexture(type) {
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 256;
            const ctx = canvas.getContext('2d');

            const colors = {
                earth: ['#1e90ff', '#228b22', '#8b4513'],
                mars: ['#cd5c5c', '#8b4513', '#a0522d'],
                jupiter: ['#daa520', '#cd853f', '#d2691e'],
                ice: ['#87ceeb', '#4682b4', '#b0e0e6'],
                lava: ['#ff4500', '#ff6347', '#8b0000']
            };

            const palette = colors[type] || colors.earth;
            
            // Background
            ctx.fillStyle = palette[0];
            ctx.fillRect(0, 0, 256, 256);

            // Stripes/patterns
            for(let i = 0; i < 8; i++) {
                ctx.fillStyle = palette[Math.floor(Math.random() * palette.length)];
                ctx.globalAlpha = 0.3 + Math.random() * 0.4;
                ctx.fillRect(0, i * 35 + Math.random() * 20, 256, 20 + Math.random() * 15);
            }

            // Craters/spots
            ctx.globalAlpha = 0.5;
            for(let i = 0; i < 15; i++) {
                const x = Math.random() * 256;
                const y = Math.random() * 256;
                const r = 5 + Math.random() * 20;
                ctx.fillStyle = palette[2];
                ctx.beginPath();
                ctx.arc(x, y, r, 0, Math.PI * 2);
                ctx.fill();
            }

            ctx.globalAlpha = 1;
            return new THREE.CanvasTexture(canvas);
        }

        const textures = {
            glow: createGlowTexture('#FFFFFF', '#00FFFF'),
            cyan: createGlowTexture('#00FFFF', '#0088FF'),
            magenta: createGlowTexture('#FF00FF', '#8800FF'),
            yellow: createGlowTexture('#FFFF00', '#FF8800'),
            star: createStarTexture()
        };

        // ==========================================
        // 3D SCENE INITIALIZATION
        // ==========================================
        function init3D() {
            const container = document.getElementById('canvas-container');
            
            // Scene
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x000000, 0.0015);

            // Camera
            camera = new THREE.PerspectiveCamera(
                60,
                window.innerWidth / window.innerHeight,
                0.1,
                2000
            );
            camera.position.set(0, 10, 120);

            // Renderer
            renderer = new THREE.WebGLRenderer({ 
                antialias: true, 
                alpha: false 
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            container.appendChild(renderer.domElement);

            // Create Galaxy
            createGalaxyCore();
            createGalaxyDisk();
            createStarField();
            createNebula();
            createPlanets();
            createPhotos();

            // Start animation
            animate();
        }

        // ==========================================
        // GALAXY CORE (Center sphere)
        // ==========================================
        function createGalaxyCore() {
            const positions = [];
            const colors = [];
            const sizes = [];

            for(let i = 0; i < CONFIG.coreParticles; i++) {
                // Sphere distribution
                const radius = Math.random() * 15 + 5;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);

                const x = radius * Math.sin(phi) * Math.cos(theta);
                const y = radius * Math.sin(phi) * Math.sin(theta);
                const z = radius * Math.cos(phi);

                positions.push(x, y, z);

                // Color gradient (center white, edge cyan)
                const dist = radius / 20;
                const r = 1.0;
                const g = 0.8 + dist * 0.2;
                const b = 0.5 + dist * 0.5;
                colors.push(r, g, b);

                sizes.push(1.0 + Math.random() * 2.0);
            }

            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            geometry.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));

            const material = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 }
                },
                vertexShader: `
                    attribute float size;
                    attribute vec3 color;
                    varying vec3 vColor;
                    uniform float time;

                    void main() {
                        vColor = color;
                        vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                        
                        float pulse = 1.0 + sin(time * 2.0 + length(position) * 0.1) * 0.3;
                        gl_PointSize = size * pulse * (300.0 / -mvPosition.z);
                        gl_Position = projectionMatrix * mvPosition;
                    }
                `,
                fragmentShader: `
                    varying vec3 vColor;

                    void main() {
                        float dist = length(gl_PointCoord - 0.5);
                        if(dist > 0.5) discard;
                        
                        float alpha = 1.0 - smoothstep(0.0, 0.5, dist);
                        gl_FragColor = vec4(vColor, alpha);
                    }
                `,
                transparent: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });

            galaxyCore = new THREE.Points(geometry, material);
            scene.add(galaxyCore);
        }

        // ==========================================
        // GALAXY DISK (Spiral arms)
        // ==========================================
        function createGalaxyDisk() {
            const positions = [];
            const colors = [];
            const sizes = [];
            const shifts = [];

            for(let i = 0; i < CONFIG.diskParticles; i++) {
                // Spiral distribution
                const r = 15 + Math.random() * 35;
                const angle = (Math.random() * Math.PI * 4) + (r * 0.1);
                const spiral = Math.pow(r / 50, 0.5);
                
                const x = r * Math.cos(angle + spiral);
                const z = r * Math.sin(angle + spiral);
                const y = (Math.random() - 0.5) * 3;

                positions.push(x, y, z);

                // Color based on radius
                const dist = r / 50;
                const r_color = 0.5 + dist * 0.5;
                const g_color = 0.3 + dist * 0.3;
                const b_color = 1.0 - dist * 0.3;
                colors.push(r_color, g_color, b_color);

                sizes.push(0.5 + Math.random() * 1.5);

                // Shift for animation
                shifts.push(
                    Math.random() * Math.PI * 2,
                    Math.random() * Math.PI * 2,
                    0.1 + Math.random() * 0.2,
                    0.2 + Math.random() * 0.3
                );
            }

            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            geometry.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));
            geometry.setAttribute('shift', new THREE.Float32BufferAttribute(shifts, 4));

            const material = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 }
                },
                vertexShader: `
                    attribute float size;
                    attribute vec3 color;
                    attribute vec4 shift;
                    varying vec3 vColor;
                    uniform float time;

                    void main() {
                        vColor = color;
                        
                        // Orbital motion
                        float t = time * shift.z;
                        float moveT = mod(shift.x + t, 6.28318);
                        float moveS = mod(shift.y + t, 6.28318);
                        
                        vec3 newPos = position;
                        newPos += vec3(
                            cos(moveS) * sin(moveT),
                            cos(moveT),
                            sin(moveS) * sin(moveT)
                        ) * shift.w;
                        
                        vec4 mvPosition = modelViewMatrix * vec4(newPos, 1.0);
                        gl_PointSize = size * (200.0 / -mvPosition.z);
                        gl_Position = projectionMatrix * mvPosition;
                    }
                `,
                fragmentShader: `
                    varying vec3 vColor;

                    void main() {
                        float dist = length(gl_PointCoord - 0.5);
                        if(dist > 0.5) discard;
                        
                        float alpha = 1.0 - smoothstep(0.0, 0.5, dist);
                        gl_FragColor = vec4(vColor, alpha * 0.8);
                    }
                `,
                transparent: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });

            galaxyDisk = new THREE.Points(geometry, material);
            scene.add(galaxyDisk);
        }

        // ==========================================
        // BACKGROUND STARS
        // ==========================================
        function createStarField() {
            const positions = [];
            const sizes = [];

            for(let i = 0; i < CONFIG.starCount; i++) {
                const radius = 200 + Math.random() * 800;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);

                const x = radius * Math.sin(phi) * Math.cos(theta);
                const y = radius * Math.sin(phi) * Math.sin(theta);
                const z = radius * Math.cos(phi);

                positions.push(x, y, z);
                sizes.push(0.5 + Math.random() * 2);
            }

            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geometry.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));

            const material = new THREE.PointsMaterial({
                size: 2,
                map: textures.star,
                transparent: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false,
                sizeAttenuation: true
            });

            starField = new THREE.Points(geometry, material);
            scene.add(starField);
        }

        // ==========================================
        // NEBULA EFFECT
        // ==========================================
        function createNebula() {
            const positions = [];
            const colors = [];
            const sizes = [];

            for(let i = 0; i < 1000; i++) {
                const radius = 40 + Math.random() * 60;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);

                const x = radius * Math.sin(phi) * Math.cos(theta);
                const y = radius * Math.sin(phi) * Math.sin(theta);
                const z = radius * Math.cos(phi);

                positions.push(x, y, z);

                // Colorful nebula
                const hue = Math.random();
                if(hue < 0.33) {
                    colors.push(1, 0.3, 0.8); // Magenta
                } else if(hue < 0.66) {
                    colors.push(0.3, 0.8, 1); // Cyan
                } else {
                    colors.push(1, 0.8, 0.3); // Yellow
                }

                sizes.push(15 + Math.random() * 25);
            }

            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            geometry.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));

            const material = new THREE.PointsMaterial({
                size: 20,
                vertexColors: true,
                transparent: true,
                opacity: 0.15,
                blending: THREE.AdditiveBlending,
                depthWrite: false,
                sizeAttenuation: true,
                map: textures.glow
            });

            nebulaParticles = new THREE.Points(geometry, material);
            scene.add(nebulaParticles);
        }

        // ==========================================
        // PLANETS
        // ==========================================
        function createPlanets() {
            const planetTypes = ['earth', 'mars', 'jupiter', 'ice', 'lava'];
            
            for(let i = 0; i < CONFIG.planetCount; i++) {
                const type = planetTypes[Math.floor(Math.random() * planetTypes.length)];
                const size = 1 + Math.random() * 3;
                
                const geometry = new THREE.SphereGeometry(size, 16, 16);
                const material = new THREE.MeshBasicMaterial({
                    map: createPlanetTexture(type),
                    transparent: false
                });

                const planet = new THREE.Mesh(geometry, material);
                
                // Random position in galaxy
                const radius = 20 + Math.random() * 40;
                const angle = Math.random() * Math.PI * 2;
                planet.position.x = radius * Math.cos(angle);
                planet.position.z = radius * Math.sin(angle);
                planet.position.y = (Math.random() - 0.5) * 10;

                // Rotation speed
                planet.userData.rotationSpeed = 0.001 + Math.random() * 0.005;
                planet.userData.orbitSpeed = 0.0001 + Math.random() * 0.0003;
                planet.userData.orbitRadius = radius;
                planet.userData.orbitAngle = angle;

                scene.add(planet);
                planets.push(planet);
            }
        }

        // ==========================================
        // PHOTOS
        // ==========================================
        function createPhotos() {
            const loader = new THREE.TextureLoader();
            const photoTextures = [];

            // Load textures
            photoFiles.forEach((file, i) => {
                loader.load(
                    file,
                    (texture) => {
                        photoTextures[i] = texture;
                        if(photoMeshes[i]) {
                            photoMeshes[i].material.map = texture;
                            photoMeshes[i].material.needsUpdate = true;
                        }
                    },
                    undefined,
                    (error) => {
                        console.warn(`Failed to load ${file}:`, error);
                    }
                );
            });

            // Create photo meshes
            const photoGeo = new THREE.PlaneGeometry(12, 12);
            const borderGeo = new THREE.PlaneGeometry(13, 13);
            const borderMat = new THREE.MeshBasicMaterial({ 
                color: 0x00ffff,
                side: THREE.DoubleSide
            });

            for(let i = 0; i < CONFIG.photoCount; i++) {
                const mat = new THREE.MeshBasicMaterial({
                    color: 0xffffff,
                    side: THREE.DoubleSide,
                    transparent: true
                });

                const mesh = new THREE.Mesh(photoGeo, mat);
                const border = new THREE.Mesh(borderGeo, borderMat);
                border.position.z = -0.1;
                mesh.add(border);

                mesh.visible = false;
                mesh.scale.set(0, 0, 0);
                mesh.userData.targetScale = 0;
                
                scene.add(mesh);
                photoMeshes.push(mesh);
            }
        }

        // ==========================================
        // ANIMATION LOOP
        // ==========================================
        function animate() {
            requestAnimationFrame(animate);
            
            const time = Date.now() * 0.001;
            const speed = 0.08;

            // Update shaders
            if(galaxyCore) galaxyCore.material.uniforms.time.value = time;
            if(galaxyDisk) galaxyDisk.material.uniforms.time.value = time;

            // State-based animation
            if(state === 'GALAXY') {
                animateGalaxyMode(time);
            } else if(state === 'EXPLODE') {
                animateExplodeMode(time);
            } else if(state === 'PHOTO') {
                animatePhotoMode(time);
            }

            // Rotate planets
            planets.forEach(planet => {
                planet.rotation.y += planet.userData.rotationSpeed;
                
                if(state === 'GALAXY') {
                    planet.userData.orbitAngle += planet.userData.orbitSpeed;
                    planet.position.x = planet.userData.orbitRadius * Math.cos(planet.userData.orbitAngle);
                    planet.position.z = planet.userData.orbitRadius * Math.sin(planet.userData.orbitAngle);
                }
            });

            // Rotate star field slowly
            if(starField) {
                starField.rotation.y += 0.0001;
            }

            // Nebula drift
            if(nebulaParticles) {
                nebulaParticles.rotation.y += 0.0002;
                nebulaParticles.rotation.x += 0.0001;
            }

            renderer.render(scene, camera);
        }

        function animateGalaxyMode(time) {
            // Rotate galaxy
            if(galaxyCore) galaxyCore.rotation.y += CONFIG.rotationSpeed * 2;
            if(galaxyDisk) galaxyDisk.rotation.y += CONFIG.rotationSpeed;

            // Hide photos
            photoMeshes.forEach(mesh => {
                mesh.scale.lerp(new THREE.Vector3(0, 0, 0), 0.1);
                if(mesh.scale.x < 0.01) mesh.visible = false;
            });

            // Camera position
            camera.position.z = THREE.MathUtils.lerp(camera.position.z, 120, 0.05);
            camera.position.y = THREE.MathUtils.lerp(camera.position.y, 10, 0.05);

            document.getElementById('photo-counter').classList.remove('visible');
            document.getElementById('swipe-indicator').classList.remove('visible');
        }

        function animateExplodeMode(time) {
            // Expand galaxy
            const targetScale = 2.0;
            if(galaxyCore) {
                galaxyCore.scale.lerp(new THREE.Vector3(targetScale, targetScale, targetScale), 0.05);
            }
            if(galaxyDisk) {
                galaxyDisk.scale.lerp(new THREE.Vector3(targetScale, targetScale, targetScale), 0.05);
            }

            // Scatter planets
            planets.forEach((planet, i) => {
                const angle = (i / planets.length) * Math.PI * 2;
                const radius = 80;
                const targetX = radius * Math.cos(angle);
                const targetZ = radius * Math.sin(angle);
                const targetY = (Math.sin(time + i) * 5);

                planet.position.x = THREE.MathUtils.lerp(planet.position.x, targetX, 0.05);
                planet.position.z = THREE.MathUtils.lerp(planet.position.z, targetZ, 0.05);
                planet.position.y = THREE.MathUtils.lerp(planet.position.y, targetY, 0.05);
            });

            // Show photos in orbit
            const baseAngle = time * 0.2;
            const angleStep = (Math.PI * 2) / CONFIG.photoCount;

            photoMeshes.forEach((mesh, i) => {
                mesh.visible = true;
                
                const angle = baseAngle + i * angleStep;
                const x = Math.sin(angle) * CONFIG.photoOrbitRadius;
                const z = Math.cos(angle) * CONFIG.photoOrbitRadius;
                const y = Math.sin(time * 0.5 + i) * 3;

                mesh.position.lerp(new THREE.Vector3(x, y, z), 0.1);
                mesh.lookAt(camera.position);

                // Scale based on depth
                const targetScale = (z > 0) ? 1.2 : 0.8;
                mesh.scale.lerp(new THREE.Vector3(targetScale, targetScale, targetScale), 0.1);
            });

            // Find closest photo
            let maxZ = -999;
            let closestIndex = 0;
            photoMeshes.forEach((mesh, i) => {
                if(mesh.position.z > maxZ) {
                    maxZ = mesh.position.z;
                    closestIndex = i;
                }
            });
            currentPhotoIndex = closestIndex;

            camera.position.z = THREE.MathUtils.lerp(camera.position.z, 80, 0.05);
            camera.position.y = THREE.MathUtils.lerp(camera.position.y, 0, 0.05);

            document.getElementById('photo-counter').classList.add('visible');
            document.getElementById('photo-counter').textContent = `${currentPhotoIndex + 1} / ${CONFIG.photoCount}`;
            document.getElementById('swipe-indicator').classList.add('visible');
        }

        function animatePhotoMode(time) {
            // Contract galaxy
            const targetScale = 0.5;
            if(galaxyCore) {
                galaxyCore.scale.lerp(new THREE.Vector3(targetScale, targetScale, targetScale), 0.05);
            }
            if(galaxyDisk) {
                galaxyDisk.scale.lerp(new THREE.Vector3(targetScale, targetScale, targetScale), 0.05);
            }

            // Hide planets
            planets.forEach(planet => {
                planet.scale.lerp(new THREE.Vector3(0.1, 0.1, 0.1), 0.1);
            });

            // Show selected photo
            photoMeshes.forEach((mesh, i) => {
                if(i === currentPhotoIndex) {
                    mesh.visible = true;
                    mesh.position.lerp(new THREE.Vector3(0, 0, 70), 0.1);
                    mesh.scale.lerp(new THREE.Vector3(6, 6, 6), 0.1);
                    mesh.lookAt(camera.position);
                    mesh.rotation.z = 0;
                } else {
                    mesh.scale.lerp(new THREE.Vector3(0, 0, 0), 0.1);
                    if(mesh.scale.x < 0.01) mesh.visible = false;
                }
            });

            camera.position.z = THREE.MathUtils.lerp(camera.position.z, 100, 0.05);

            document.getElementById('photo-counter').classList.add('visible');
            document.getElementById('photo-counter').textContent = `${currentPhotoIndex + 1} / ${CONFIG.photoCount}`;
            document.getElementById('swipe-indicator').classList.remove('visible');
        }

        // ==========================================
        // CAMERA TOGGLE
        // ==========================================
        let cameraExpanded = false;
        
        function toggleCamera() {
            const container = document.getElementById('camera-container');
            const button = document.getElementById('camera-toggle');
            
            cameraExpanded = !cameraExpanded;
            
            if(cameraExpanded) {
                container.classList.remove('minimized');
                container.classList.add('expanded');
                button.textContent = 'üìπ THU NH·ªé';
            } else {
                container.classList.remove('expanded');
                container.classList.add('minimized');
                button.textContent = 'üìπ M·ªû R·ªòNG';
            }
        }

        // ==========================================
        // DRAW HAND SKELETON
        // ==========================================
        function drawHandLandmarks(ctx, landmarks, width, height) {
            // Draw connections
            const connections = [
                [0,1],[1,2],[2,3],[3,4], // Thumb
                [0,5],[5,6],[6,7],[7,8], // Index
                [0,9],[9,10],[10,11],[11,12], // Middle
                [0,13],[13,14],[14,15],[15,16], // Ring
                [0,17],[17,18],[18,19],[19,20], // Pinky
                [5,9],[9,13],[13,17] // Palm
            ];

            ctx.strokeStyle = 'rgba(0, 255, 255, 0.8)';
            ctx.lineWidth = 3;
            
            connections.forEach(([start, end]) => {
                const startPoint = landmarks[start];
                const endPoint = landmarks[end];
                
                ctx.beginPath();
                ctx.moveTo(startPoint.x * width, startPoint.y * height);
                ctx.lineTo(endPoint.x * width, endPoint.y * height);
                ctx.stroke();
            });

            // Draw landmarks
            landmarks.forEach((landmark, i) => {
                const x = landmark.x * width;
                const y = landmark.y * height;
                
                // Different colors for different parts
                if(i === 0) {
                    ctx.fillStyle = '#ff0066'; // Wrist - pink
                } else if([4,8,12,16,20].includes(i)) {
                    ctx.fillStyle = '#00ff00'; // Fingertips - green
                } else {
                    ctx.fillStyle = '#00ffff'; // Others - cyan
                }
                
                ctx.beginPath();
                ctx.arc(x, y, 5, 0, Math.PI * 2);
                ctx.fill();
                
                // White border
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 2;
                ctx.stroke();
            });
        }

        // ==========================================
        // HAND GESTURE DETECTION
        // ==========================================
        function startHandTracking() {
            const video = document.getElementsByClassName('input_video')[0];
            const canvas = document.getElementById('camera-preview');
            const ctx = canvas.getContext('2d');
            const statusBadge = document.getElementById('status-badge');
            const cameraStatus = document.getElementById('camera-status');

            let frameCnt = 0;
            const hands = new Hands({
                locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
            });

            hands.setOptions({
                maxNumHands: 1,
                modelComplexity: 0,
                minDetectionConfidence: 0.5,
                minTrackingConfidence: 0.5
            });

            hands.onResults(results => {
                // Clear and draw video frame
                ctx.save();
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.scale(-1, 1);
                ctx.drawImage(results.image, -canvas.width, 0, canvas.width, canvas.height);
                ctx.restore();

                if(results.multiHandLandmarks.length > 0) {
                    const lm = results.multiHandLandmarks[0];
                    
                    // Draw hand skeleton
                    drawHandLandmarks(ctx, lm, canvas.width, canvas.height);
                    
                    // Track hand X position
                    prevHandX = handX;
                    handX = lm[9].x;
                    swipeVelocity = handX - prevHandX;

                    // Calculate gestures
                    const tips = [8, 12, 16, 20];
                    const wrist = lm[0];
                    let openDist = 0;
                    tips.forEach(i => {
                        openDist += Math.hypot(lm[i].x - wrist.x, lm[i].y - wrist.y);
                    });
                    const avgDist = openDist / 4;

                    // Detect swipe gesture
                    if(state === 'EXPLODE' && Math.abs(swipeVelocity) > CONFIG.swipeThreshold) {
                        if(swipeVelocity > 0) {
                            // Swipe right -> previous photo
                            currentPhotoIndex = (currentPhotoIndex - 1 + CONFIG.photoCount) % CONFIG.photoCount;
                        } else {
                            // Swipe left -> next photo
                            currentPhotoIndex = (currentPhotoIndex + 1) % CONFIG.photoCount;
                        }
                    }

                    // State transitions
                    if(avgDist < 0.25) {
                        // Fist -> GALAXY
                        state = 'GALAXY';
                        statusBadge.innerHTML = '‚úä THU GALAXY';
                        statusBadge.style.color = '#00ffff';
                        statusBadge.style.borderColor = 'rgba(0, 255, 255, 0.6)';
                        cameraStatus.textContent = '‚úä N·∫ÆM TAY';
                        cameraStatus.className = 'detecting';
                        cameraStatus.style.color = '#00ffff';
                    } else if(avgDist > 0.45) {
                        // Open hand -> EXPLODE
                        state = 'EXPLODE';
                        statusBadge.innerHTML = 'üñê KH√ÅM PH√Å H√ÄNH TINH';
                        statusBadge.style.color = '#ff00ff';
                        statusBadge.style.borderColor = 'rgba(255, 0, 255, 0.6)';
                        cameraStatus.textContent = 'üñê X√íE TAY';
                        cameraStatus.className = 'detecting';
                        cameraStatus.style.color = '#ff00ff';
                    } else {
                        // Partial -> PHOTO
                        state = 'PHOTO';
                        statusBadge.innerHTML = 'üì∏ XEM ·∫¢NH';
                        statusBadge.style.color = '#ffff00';
                        statusBadge.style.borderColor = 'rgba(255, 255, 0, 0.6)';
                        cameraStatus.textContent = 'üì∏ ƒêANG XEM';
                        cameraStatus.className = 'detecting';
                        cameraStatus.style.color = '#ffff00';
                    }

                    // Draw gesture info on canvas
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                    ctx.fillRect(10, canvas.height - 40, 200, 30);
                    ctx.fillStyle = '#00ffff';
                    ctx.font = '14px Space Mono';
                    ctx.fillText(`ƒê·ªô m·ªü: ${(avgDist * 100).toFixed(0)}%`, 15, canvas.height - 18);

                } else {
                    // No hand detected
                    state = 'GALAXY';
                    statusBadge.innerHTML = 'üåå KH√ÅM PH√Å V≈® TR·ª§ üåå';
                    statusBadge.style.color = '#00ffff';
                    statusBadge.style.borderColor = 'rgba(0, 255, 255, 0.6)';
                    cameraStatus.textContent = 'ƒêang t√¨m tay...';
                    cameraStatus.className = 'no-hand';
                    cameraStatus.style.color = '#ff9900';
                }
            });

            const cameraUtils = new Camera(video, {
                onFrame: async () => {
                    frameCnt++;
                    if(frameCnt % 2 !== 0) return;
                    await hands.send({ image: video });
                },
                width: 640,
                height: 480
            });

            cameraUtils.start();
        }

        // ==========================================
        // START SYSTEM
        // ==========================================
        function startSystem() {
            const splash = document.getElementById('splash-screen');
            splash.classList.add('hidden');

            setTimeout(() => {
                splash.style.display = 'none';
                document.getElementById('ui-layer').style.display = 'block';
            }, 1000);

            // Start music
            bgMusic.play().catch(e => console.log('Music autoplay blocked:', e));

            // Initialize 3D
            init3D();

            // Start hand tracking
            startHandTracking();
        }

        // ==========================================
        // EVENT LISTENERS
        // ==========================================
        document.getElementById('start-button').addEventListener('click', startSystem);

        window.addEventListener('resize', () => {
            if(camera && renderer) {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            }
        });

        // Custom cursor tracking
        document.addEventListener('mousemove', (e) => {
            const cursor = document.getElementById('custom-cursor');
            cursor.style.left = e.clientX + 'px';
            cursor.style.top = e.clientY + 'px';
        });

        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            if(e.key === 'ArrowLeft') {
                currentPhotoIndex = (currentPhotoIndex - 1 + CONFIG.photoCount) % CONFIG.photoCount;
            } else if(e.key === 'ArrowRight') {
                currentPhotoIndex = (currentPhotoIndex + 1) % CONFIG.photoCount;
            } else if(e.key === ' ') {
                state = (state === 'GALAXY') ? 'EXPLODE' : 'GALAXY';
            }
        });

        // Error handling
        window.addEventListener('error', (e) => {
            console.error('Error:', e.error);
        });
    </script>
</body>
</html>
