<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js Hand Control Particles</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #111; font-family: 'Segoe UI', sans-serif; }
        
        /* Container chính cho 3D Canvas */
        #canvas-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }

        /* Giao diện UI */
        #ui-container {
            position: absolute; top: 20px; left: 20px; z-index: 10;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            padding: 20px;
            border-radius: 12px;
            border: 1px solid rgba(255,255,255,0.2);
            color: white;
            width: 280px;
        }

        h2 { margin: 0 0 10px 0; font-size: 1.2rem; font-weight: 600; }
        p { font-size: 0.9rem; color: #ddd; line-height: 1.4; margin-bottom: 15px; }

        .control-group { margin-bottom: 15px; display: flex; align-items: center; justify-content: space-between; }
        label { font-size: 0.9rem; }
        
        input[type="color"] {
            border: none; width: 40px; height: 40px; cursor: pointer; background: none;
        }

        /* Camera Preview nhỏ ở góc */
        #video-preview {
            position: absolute; bottom: 20px; right: 20px; z-index: 10;
            width: 160px; height: 120px;
            border-radius: 8px;
            transform: scaleX(-1); /* Gương */
            border: 2px solid rgba(255,255,255,0.3);
            object-fit: cover;
            background: #000;
        }

        #status { font-size: 0.8rem; color: #4caf50; margin-top: 5px; font-weight: bold; }
        .loading { color: #ff9800 !important; }
    </style>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <video id="input_video" style="display:none"></video>
    
    <canvas id="video-preview"></canvas>

    <div id="ui-container">
        <h2>Điều khiển Hạt 3D</h2>
        <p>Đưa 2 bàn tay lên camera. Di chuyển 2 tay ra xa/lại gần để mở rộng/thu nhỏ khối cầu.</p>
        
        <div class="control-group">
            <label for="colorPicker">Màu sắc hạt:</label>
            <input type="color" id="colorPicker" value="#00ffff">
        </div>
        <div id="status" class="loading">Đang tải Camera & AI...</div>
    </div>

    <div id="canvas-container"></div>

<script>
    // --- CẤU HÌNH ---
    const PARTICLE_COUNT = 3000;
    const SPHERE_RADIUS = 10; // Bán kính cơ bản khi thu gọn
    let expandFactor = 1; // 1 = hình cầu, >1 = mở rộng
    let targetExpandFactor = 1;
    let particleColor = new THREE.Color(0x00ffff);

    // --- 1. THIẾT LẬP THREE.JS ---
    const container = document.getElementById('canvas-container');
    const scene = new THREE.Scene();
    
    // Camera 3D
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.z = 40;

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    container.appendChild(renderer.domElement);

    // Tạo hạt (Particles)
    const geometry = new THREE.BufferGeometry();
    const positions = [];
    const basePositions = []; // Lưu vị trí gốc (hình cầu) để tính toán

    // Toán học để rải điểm đều lên mặt cầu (Fibonacci Sphere) hoặc Random Sphere
    for (let i = 0; i < PARTICLE_COUNT; i++) {
        // Tọa độ cầu ngẫu nhiên
        const phi = Math.acos(-1 + (2 * i) / PARTICLE_COUNT);
        const theta = Math.sqrt(PARTICLE_COUNT * Math.PI) * phi;

        const x = SPHERE_RADIUS * Math.cos(theta) * Math.sin(phi);
        const y = SPHERE_RADIUS * Math.sin(theta) * Math.sin(phi);
        const z = SPHERE_RADIUS * Math.cos(phi);

        positions.push(x, y, z);
        basePositions.push(x, y, z);
    }

    geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));

    const material = new THREE.PointsMaterial({
        color: particleColor,
        size: 0.3,
        transparent: true,
        opacity: 0.8,
        blending: THREE.AdditiveBlending
    });

    const particlesMesh = new THREE.Points(geometry, material);
    scene.add(particlesMesh);

    // Xử lý đổi màu
    document.getElementById('colorPicker').addEventListener('input', (e) => {
        material.color.set(e.target.value);
    });

    // Resize window
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // --- 2. LOGIC ANIMATION & UPDATE ---
    const clock = new THREE.Clock();

    function animate() {
        requestAnimationFrame(animate);

        const time = clock.getElapsedTime();

        // Hiệu ứng "Interpolation" mượt mà (Lerp)
        // Di chuyển dần giá trị hiện tại tới giá trị mục tiêu
        expandFactor += (targetExpandFactor - expandFactor) * 0.1;

        const positionsAttribute = geometry.attributes.position;
        const pArray = positionsAttribute.array;

        // Cập nhật vị trí từng hạt
        for (let i = 0; i < PARTICLE_COUNT; i++) {
            const ix = i * 3;
            const iy = i * 3 + 1;
            const iz = i * 3 + 2;

            // Lấy vị trí gốc trên hình cầu
            const bx = basePositions[ix];
            const by = basePositions[iy];
            const bz = basePositions[iz];

            // Thêm chút nhiễu (noise) để hạt trông sống động
            const noise = Math.sin(time * 2 + bx) * 0.2;

            // Công thức: Vị trí mới = Vị trí gốc * Hệ số mở rộng + Nhiễu
            pArray[ix] = bx * expandFactor + noise;
            pArray[iy] = by * expandFactor + noise;
            pArray[iz] = bz * expandFactor + noise;
        }

        positionsAttribute.needsUpdate = true;
        
        // Tự động xoay nhẹ khối cầu
        particlesMesh.rotation.y += 0.002;
        particlesMesh.rotation.x += 0.001;

        renderer.render(scene, camera);
    }
    animate();

    // --- 3. MEDIAPIPE HANDS SETUP ---
    const videoElement = document.getElementById('input_video');
    const previewCanvas = document.getElementById('video-preview');
    const previewCtx = previewCanvas.getContext('2d');
    const statusText = document.getElementById('status');

    function onResults(results) {
        // Vẽ preview camera nhỏ
        previewCanvas.width = results.image.width;
        previewCanvas.height = results.image.height;
        previewCtx.drawImage(results.image, 0, 0, previewCanvas.width, previewCanvas.height);
        
        // Vẽ khung xương tay lên preview (tuỳ chọn)
        if (results.multiHandLandmarks) {
            for (const landmarks of results.multiHandLandmarks) {
                drawConnectors(previewCtx, landmarks, HAND_CONNECTIONS, {color: '#00FF00', lineWidth: 2});
            }
        }

        // --- LOGIC PHÁT HIỆN CỬ CHỈ ---
        if (results.multiHandLandmarks && results.multiHandLandmarks.length === 2) {
            // Lấy tọa độ 2 bàn tay
            const hand1 = results.multiHandLandmarks[0];
            const hand2 = results.multiHandLandmarks[1];

            // Lấy vị trí ngón trỏ (Index Finger Tip - điểm số 8) của mỗi tay
            const p1 = hand1[8];
            const p2 = hand2[8];

            // Tính khoảng cách Euclidean giữa 2 ngón trỏ
            // p1.x, p1.y nằm trong khoảng 0.0 -> 1.0
            const dx = p1.x - p2.x;
            const dy = p1.y - p2.y;
            const distance = Math.sqrt(dx*dx + dy*dy);

            // Map khoảng cách (thường từ 0.05 đến 0.8) sang hệ số mở rộng (1 đến 4)
            // Càng xa -> càng to
            let newFactor = 1 + (distance * 4); 
            if (newFactor < 1) newFactor = 1;
            if (newFactor > 5) newFactor = 5; // Giới hạn max

            targetExpandFactor = newFactor;
            statusText.innerText = "Đã nhận diện 2 tay: Đang điều khiển";
            statusText.style.color = "#4caf50";
        } else {
            // Nếu không đủ 2 tay, thu về hình cầu
            targetExpandFactor = 1;
            if(results.multiHandLandmarks.length > 0) {
                 statusText.innerText = "Cần cả 2 tay để mở rộng";
                 statusText.style.color = "#ffeb3b";
            } else {
                 statusText.innerText = "Đang chờ bàn tay...";
                 statusText.style.color = "#4caf50";
            }
        }
    }

    const hands = new Hands({locateFile: (file) => {
        return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
    }});

    hands.setOptions({
        maxNumHands: 2,
        modelComplexity: 1,
        minDetectionConfidence: 0.5,
        minTrackingConfidence: 0.5
    });

    hands.onResults(onResults);

    const cameraFeed = new Camera(videoElement, {
        onFrame: async () => {
            await hands.send({image: videoElement});
        },
        width: 640,
        height: 480
    });

    // Bắt đầu Camera
    statusText.innerText = "Đang khởi động Camera...";
    cameraFeed.start()
        .then(() => {
            statusText.innerText = "Hệ thống sẵn sàng";
            statusText.classList.remove('loading');
        })
        .catch(err => {
            console.error(err);
            statusText.innerText = "Lỗi Camera: Kiểm tra quyền truy cập";
            statusText.style.color = "red";
        });

</script>
</body>
</html>
