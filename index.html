<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <title>Awaken The Universe - MASTERPIECE</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap');
        
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body {
            width: 100%; height: 100%; overflow: hidden;
            background: #000; touch-action: none;
            font-family: 'Orbitron', sans-serif;
        }
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; z-index: 10;
        }
        #hint {
            position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            color: rgba(255, 230, 255, 0.95);
            font-size: 28px; text-align: center;
            text-shadow: 0 0 40px rgba(255, 100, 255, 1), 0 0 80px rgba(100, 100, 255, 0.8);
            animation: pulse 3s ease-in-out infinite;
            transition: opacity 1s ease;
            letter-spacing: 4px;
            font-weight: 700;
        }
        @keyframes pulse {
            0%, 100% { 
                opacity: 0.7; 
                transform: translate(-50%, -50%) scale(1); 
                text-shadow: 0 0 30px rgba(255, 100, 255, 0.6); 
            }
            50% { 
                opacity: 1; 
                transform: translate(-50%, -50%) scale(1.08); 
                text-shadow: 0 0 60px rgba(255, 100, 255, 1), 0 0 100px rgba(100, 100, 255, 1); 
            }
        }
        #backHint {
            position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%);
            color: rgba(100, 200, 255, 0.7); font-size: 15px;
            opacity: 0; transition: opacity 1s ease;
            letter-spacing: 2px;
            text-shadow: 0 0 20px rgba(100, 200, 255, 0.8);
        }
        #loading {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: #fff; font-size: 18px; z-index: 20;
            background: rgba(20,0,40,0.9); padding: 20px 40px; border-radius: 50px;
            border: 2px solid rgba(255,100,255,0.5);
            box-shadow: 0 0 40px rgba(255,100,255,0.3);
        }
    </style>
</head>
<body>
    <div id="loading">‚ú® ƒêang kh·ªüi t·∫°o v≈© tr·ª•...</div>
    <div id="ui-layer">
        <div id="hint" style="opacity: 0;">üåå CH·∫†M ƒê·ªÇ ƒê√ÅNH TH·ª®C üåå</div>
        <div id="backHint">‚Üê Chu·ªôt ph·∫£i ƒë·ªÉ quay v·ªÅ ‚Üí</div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // ============================================================================
        // SETUP
        // ============================================================================
        
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x0a0520, 0.0004);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 10000);
        camera.position.set(0, 20, 100);
        camera.lookAt(0, 40, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance" });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
        renderer.toneMapping = THREE.ReinhardToneMapping;
        renderer.toneMappingExposure = 1.2;
        document.body.appendChild(renderer.domElement);

        // POST-PROCESSING
        const renderScene = new RenderPass(scene, camera);
        const bloomPass = new UnrealBloomPass(
            new THREE.Vector2(window.innerWidth, window.innerHeight),
            2.0, 0.5, 0.8
        );
        const composer = new EffectComposer(renderer);
        composer.addPass(renderScene);
        composer.addPass(bloomPass);

        // ============================================================================
        // TEXTURES
        // ============================================================================

        function createTexture(type) {
            const canvas = document.createElement('canvas');
            canvas.width = 256; canvas.height = 256;
            const ctx = canvas.getContext('2d');
            const cx = 128, cy = 128;

            if (type === 'glow') {
                const g = ctx.createRadialGradient(cx, cy, 0, cx, cy, 128);
                g.addColorStop(0, 'rgba(255,255,255,1)');
                g.addColorStop(0.15, 'rgba(240,240,255,0.8)');
                g.addColorStop(0.4, 'rgba(150,150,255,0.3)');
                g.addColorStop(1, 'rgba(0,0,0,0)');
                ctx.fillStyle = g;
                ctx.fillRect(0,0,256,256);
            } else if (type === 'flare') {
                const g = ctx.createRadialGradient(cx,cy,0, cx,cy,128);
                g.addColorStop(0, 'rgba(255,255,255,1)');
                g.addColorStop(0.3, 'rgba(255,255,255,0.5)');
                g.addColorStop(1, 'rgba(0,0,0,0)');
                ctx.fillStyle = g; 
                ctx.fillRect(0,0,256,256);
                ctx.fillStyle = 'rgba(255,255,255,0.9)';
                ctx.fillRect(0, 126, 256, 4);
                ctx.fillRect(126, 0, 4, 256);
            } else if (type === 'dust') {
                const imgData = ctx.createImageData(256,256);
                for(let i=0; i<imgData.data.length; i+=4) {
                    const v = Math.random();
                    if(v > 0.88) {
                        imgData.data[i] = 150 + v * 105;
                        imgData.data[i+1] = 140 + v * 115;
                        imgData.data[i+2] = 180 + v * 75;
                        imgData.data[i+3] = v * 60;
                    }
                }
                ctx.putImageData(imgData, 0, 0);
            }
            return new THREE.CanvasTexture(canvas);
        }

        const texGlow = createTexture('glow');
        const texFlare = createTexture('flare');
        const texDust = createTexture('dust');

        // ============================================================================
        // SKY
        // ============================================================================

        const skyGeo = new THREE.SphereGeometry(5000, 32, 32);
        const skyMat = new THREE.ShaderMaterial({
            uniforms: {
                topColor: { value: new THREE.Color(0x0a0520) },
                bottomColor: { value: new THREE.Color(0x2a1550) },
                horizonColor: { value: new THREE.Color(0x4a2080) },
                offset: { value: 30 },
                exponent: { value: 0.5 }
            },
            vertexShader: `
                varying vec3 vWorldPosition;
                void main() {
                    vec4 worldPosition = modelMatrix * vec4(position, 1.0);
                    vWorldPosition = worldPosition.xyz;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                uniform vec3 topColor;
                uniform vec3 bottomColor;
                uniform vec3 horizonColor;
                uniform float offset;
                uniform float exponent;
                varying vec3 vWorldPosition;
                void main() {
                    float h = normalize(vWorldPosition + offset).y;
                    float t = max(pow(max(h, 0.0), exponent), 0.0);
                    vec3 skyColor = mix(bottomColor, topColor, t);
                    float horizonGlow = exp(-abs(h) * 2.5) * 0.6;
                    skyColor = mix(skyColor, horizonColor, horizonGlow);
                    gl_FragColor = vec4(skyColor, 1.0);
                }
            `,
            side: THREE.BackSide
        });
        const sky = new THREE.Mesh(skyGeo, skyMat);
        scene.add(sky);

        // ============================================================================
        // BACKGROUND STARS
        // ============================================================================

        function createSimpleStars(count, size, range, depth) {
            const geo = new THREE.BufferGeometry();
            const pos = [];
            const col = [];

            for(let i=0; i<count; i++) {
                const r = 1000 + Math.random() * range;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                
                pos.push(
                    r * Math.sin(phi) * Math.cos(theta),
                    r * Math.sin(phi) * Math.sin(theta) * 0.3,
                    r * Math.cos(phi) + depth
                );

                const c = new THREE.Color();
                c.setHSL(Math.random() * 0.1 + 0.55, 0.6, 0.5 + Math.random() * 0.3);
                col.push(c.r, c.g, c.b);
            }

            geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
            geo.setAttribute('color', new THREE.Float32BufferAttribute(col, 3));

            const mat = new THREE.PointsMaterial({
                size: size,
                map: texGlow,
                vertexColors: true,
                transparent: true,
                opacity: 0.5,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });

            return new THREE.Points(geo, mat);
        }

        const bgStars1 = createSimpleStars(8000, 2, 3000, -1000);
        const bgStars2 = createSimpleStars(5000, 3, 2000, 0);
        const bgStars3 = createSimpleStars(300, 8, 2000, 300);
        scene.add(bgStars1, bgStars2, bgStars3);

        // ============================================================================
        // COSMIC DUST
        // ============================================================================

        const dustGroup = new THREE.Group();
        for(let i=0; i<3; i++) {
            const geo = new THREE.PlaneGeometry(3500, 2200);
            const mat = new THREE.MeshBasicMaterial({
                map: texDust,
                transparent: true,
                opacity: 0.07 - i * 0.02,
                blending: THREE.AdditiveBlending,
                side: THREE.DoubleSide,
                depthWrite: false
            });
            const mesh = new THREE.Mesh(geo, mat);
            mesh.position.set(0, 80 + i*60, -600 - i*250);
            mesh.rotation.x = -0.2;
            mesh.userData = { speed: 0.008 + i * 0.003, offset: Math.random() * 100 };
            dustGroup.add(mesh);
        }
        scene.add(dustGroup);

        // ============================================================================
        // GROUND
        // ============================================================================

        const groundGeo = new THREE.PlaneGeometry(6000, 3000);
        const groundMat = new THREE.MeshBasicMaterial({ 
            color: 0x050515, 
            transparent: true, 
            opacity: 0.95 
        });
        const ground = new THREE.Mesh(groundGeo, groundMat);
        ground.rotation.x = -Math.PI / 2;
        ground.position.y = -120;
        scene.add(ground);

        // ============================================================================
        // GALAXY WITH CUSTOM SHADER
        // ============================================================================

        const galaxyGroup = new THREE.Group();
        galaxyGroup.visible = false;
        scene.add(galaxyGroup);

        const gu = { time: { value: 0 } };

        function createGalaxyWithShader() {
            let sizes = [];
            let shift = [];
            let pts = [];

            const pushShift = () => {
                shift.push(
                    Math.random() * Math.PI,
                    Math.random() * Math.PI * 2,
                    (Math.random() * 0.9 + 0.1) * Math.PI * 0.08,
                    Math.random() * 0.7 + 0.3
                );
            }

            // Core (50k particles)
            for(let i=0; i<50000; i++) {
                sizes.push(Math.random() * 1.8 + 0.8);
                pushShift();
                pts.push(new THREE.Vector3()
                    .randomDirection()
                    .multiplyScalar(Math.random() * 0.4 + 8));
            }

            // Disk (100k particles)
            for(let i=0; i<100000; i++) {
                let r = 8, R = 50;
                let rand = Math.pow(Math.random(), 1.3);
                let radius = Math.sqrt(R * R * rand + (1 - rand) * r * r);
                
                pts.push(new THREE.Vector3().setFromCylindricalCoords(
                    radius, 
                    Math.random() * 2 * Math.PI, 
                    (Math.random() - 0.5) * (3 - radius/20)
                ));
                
                sizes.push(Math.random() * 1.5 + 0.5);
                pushShift();
            }

            const geo = new THREE.BufferGeometry().setFromPoints(pts);
            geo.setAttribute("sizes", new THREE.Float32BufferAttribute(sizes, 1));
            geo.setAttribute("shift", new THREE.Float32BufferAttribute(shift, 4));

            const mat = new THREE.PointsMaterial({
                size: 0.15,
                transparent: true,
                depthTest: false,
                blending: THREE.AdditiveBlending,
                onBeforeCompile: shader => {
                    shader.uniforms.time = gu.time;
                    shader.vertexShader = `
                        uniform float time;
                        attribute float sizes;
                        attribute vec4 shift;
                        varying vec3 vColor;
                        ${shader.vertexShader}
                    `.replace(
                        `gl_PointSize = size;`,
                        `gl_PointSize = size * sizes;`
                    ).replace(
                        `#include <color_vertex>`,
                        `#include <color_vertex>
                        float d = length(abs(position) / vec3(50., 15., 50.));
                        d = clamp(d, 0., 1.);
                        vColor = mix(vec3(255., 220., 150.), vec3(150., 100., 255.), d) / 255.;
                        vColor *= (1.5 + sin(time * 0.5 + position.x * 0.01) * 0.3);
                        `
                    ).replace(
                        `#include <begin_vertex>`,
                        `#include <begin_vertex>
                        float t = time;
                        float moveT = mod(shift.x + shift.z * t, 6.28318);
                        float moveS = mod(shift.y + shift.z * t, 6.28318);
                        transformed += vec3(
                            cos(moveS) * sin(moveT), 
                            cos(moveT), 
                            sin(moveS) * sin(moveT)
                        ) * shift.a;
                        `
                    );
                    
                    shader.fragmentShader = `
                        varying vec3 vColor;
                        ${shader.fragmentShader}
                    `.replace(
                        `#include <clipping_planes_fragment>`,
                        `#include <clipping_planes_fragment>
                        float d = length(gl_PointCoord.xy - 0.5);
                        `
                    ).replace(
                        `vec4 diffuseColor = vec4( diffuse, opacity );`,
                        `vec4 diffuseColor = vec4( vColor, smoothstep(0.5, 0.1, d) );`
                    );
                }
            });

            const points = new THREE.Points(geo, mat);
            points.rotation.order = "ZYX";
            points.rotation.z = 0.15;
            return points;
        }

        const galaxyPoints = createGalaxyWithShader();
        galaxyGroup.add(galaxyPoints);

        // Core glow
        const coreGlow = new THREE.Sprite(new THREE.SpriteMaterial({
            map: texGlow, 
            color: 0xffdd99, 
            blending: THREE.AdditiveBlending, 
            transparent: true,
            opacity: 0.9
        }));
        coreGlow.scale.set(150, 150, 1);
        galaxyGroup.add(coreGlow);

        // Core light
        const coreLight = new THREE.PointLight(0xffcc88, 3, 800);
        galaxyGroup.add(coreLight);

        // ============================================================================
        // FLOATING CARDS
        // ============================================================================

        const cardGroup = new THREE.Group();
        galaxyGroup.add(cardGroup);

        function createCardTexture(idx) {
            const cvs = document.createElement('canvas');
            cvs.width = 400; cvs.height = 500;
            const ctx = cvs.getContext('2d');
            
            const g = ctx.createLinearGradient(0,0,400,500);
            g.addColorStop(0, `hsl(${idx*45 + 180}, 80%, 25%)`);
            g.addColorStop(1, `hsl(${idx*45 + 180}, 80%, 10%)`);
            ctx.fillStyle = g; 
            ctx.fillRect(0,0,400,500);
            
            ctx.strokeStyle = `hsl(${idx*45 + 180}, 100%, 70%)`; 
            ctx.lineWidth = 15;
            ctx.strokeRect(10,10,380,480);
            
            const g2 = ctx.createRadialGradient(200,200,0,200,200,200);
            g2.addColorStop(0, `hsla(${idx*45 + 180}, 100%, 70%, 0.4)`);
            g2.addColorStop(1, `hsla(${idx*45 + 180}, 100%, 70%, 0)`);
            ctx.fillStyle = g2;
            ctx.fillRect(0,0,400,500);
            
            ctx.fillStyle = '#fff'; 
            ctx.font = 'bold 120px Arial'; 
            ctx.textAlign = 'center';
            ctx.fillText((idx+1).toString().padStart(2,'0'), 200, 220);
            
            ctx.font = '40px Arial';
            ctx.fillText("‚óÜ MEMORY ‚óÜ", 200, 300);
            
            ctx.font = '28px Arial';
            ctx.fillStyle = 'rgba(255,255,255,0.6)';
            ctx.fillText(`Coordinate ${idx*1111}`, 200, 400);
            
            return new THREE.CanvasTexture(cvs);
        }

        const cards = [];
        for(let i=0; i<10; i++) {
            const tex = createCardTexture(i);
            const geo = new THREE.PlaneGeometry(35, 44);
            const mat = new THREE.MeshBasicMaterial({ 
                map: tex, 
                side: THREE.DoubleSide, 
                transparent: true, 
                opacity: 0 
            });
            const mesh = new THREE.Mesh(geo, mat);
            
            const angle = (i / 10) * Math.PI * 2;
            const radius = 120 + (i % 3) * 25;
            mesh.position.set(
                Math.cos(angle) * radius, 
                Math.sin(angle * 2.5) * 35, 
                Math.sin(angle) * radius
            );
            
            mesh.userData = { 
                angle: angle, 
                radius: radius,
                speed: 0.001 + Math.random() * 0.0005, 
                baseY: mesh.position.y,
                fadeDelay: i * 0.2,
                fadeProgress: 0
            };
            
            cardGroup.add(mesh);
            cards.push(mesh);
        }

        // ============================================================================
        // METEORS
        // ============================================================================

        const meteors = [];
        function createMeteor() {
            const group = new THREE.Group();
            
            const headGeo = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0,0,0)]);
            const headMat = new THREE.PointsMaterial({
                color: 0xffffff, 
                size: 12, 
                map: texFlare, 
                transparent: true, 
                blending: THREE.AdditiveBlending
            });
            const head = new THREE.Points(headGeo, headMat);
            group.add(head);
            
            const tailPoints = [];
            for(let i=0; i<30; i++) {
                tailPoints.push(new THREE.Vector3(-i*3, i*0.5, 0));
            }
            const tailGeo = new THREE.BufferGeometry().setFromPoints(tailPoints);
            const tailMat = new THREE.LineBasicMaterial({
                color: 0xaaddff, 
                transparent: true, 
                opacity: 0.6, 
                blending: THREE.AdditiveBlending
            });
            const tail = new THREE.Line(tailGeo, tailMat);
            group.add(tail);
            
            group.visible = false;
            scene.add(group);
            
            return { mesh: group, active: false, speed: 0 };
        }

        for(let i=0; i<15; i++) meteors.push(createMeteor());

        // ============================================================================
        // INTERACTION & ANIMATION
        // ============================================================================

        document.getElementById('loading').style.display = 'none';
        document.getElementById('hint').style.opacity = 1;

        let state = 'GROUND';
        let time = 0;
        let transitionProgress = 0;
        let galaxyTime = 0;
        let mouseX = 0, mouseY = 0;

        document.addEventListener('mousemove', (e) => {
            mouseX = (e.clientX - window.innerWidth/2) / window.innerWidth;
            mouseY = (e.clientY - window.innerHeight/2) / window.innerHeight;
        });

        function awaken() {
            if (state !== 'GROUND') return;
            state = 'TRANSITION';
            document.getElementById('hint').style.opacity = 0;
            
            galaxyGroup.visible = true;
            galaxyGroup.scale.set(0.01, 0.01, 0.01);
            bloomPass.strength = 3.5;
        }

        function reset() {
            if (state !== 'SPACE') return;
            state = 'GROUND';
            galaxyGroup.visible = false;
            document.getElementById('hint').style.opacity = 1;
            document.getElementById('backHint').style.opacity = 0;
            
            camera.position.set(0, 20, 100);
            camera.lookAt(0, 40, 0);
            bloomPass.strength = 2.0;
            transitionProgress = 0;
            galaxyTime = 0;
            
            cards.forEach(c => {
                c.material.opacity = 0;
                c.userData.fadeProgress = 0;
            });
        }

        window.addEventListener('mousedown', awaken);
        window.addEventListener('touchstart', awaken);
        window.addEventListener('contextmenu', (e) => { 
            e.preventDefault(); 
            reset(); 
        });

        // ============================================================================
        // RENDER LOOP
        // ============================================================================

        function animate() {
            requestAnimationFrame(animate);
            time += 0.01;

            // Background stars rotation
            bgStars1.rotation.y += 0.0001;
            bgStars2.rotation.y += 0.0003;
            bgStars3.rotation.y += 0.0005;

            // Dust movement
            dustGroup.children.forEach(d => {
                d.position.x = Math.sin(time * 0.15 + d.userData.offset) * 80;
                d.position.y += Math.cos(time * 0.08) * 0.08;
            });

            // Meteors
            meteors.forEach(m => {
                if (!m.active) {
                    if (Math.random() < 0.003) {
                        m.active = true;
                        m.mesh.visible = true;
                        m.mesh.position.set(
                            (Math.random() - 0.5) * 1500,
                            Math.random() * 600 + 300,
                            (Math.random() - 0.5) * 800 - 600
                        );
                        m.speed = 6 + Math.random() * 6;
                    }
                } else {
                    m.mesh.position.x -= m.speed;
                    m.mesh.position.y -= m.speed * 0.4;
                    if (m.mesh.position.y < -150 || m.mesh.position.x < -1500) {
                        m.active = false;
                        m.mesh.visible = false;
                    }
                }
            });

            // STATE MACHINE
            if (state === 'GROUND') {
                camera.position.y = 20 + Math.sin(time * 0.5) * 2.5;
                camera.position.x += (mouseX * 60 - camera.position.x) * 0.04;
                camera.position.z = 100 + Math.cos(time * 0.3) * 6;
                camera.lookAt(0, 40 + mouseY * 30, 0);

            } else if (state === 'TRANSITION') {
                transitionProgress += 0.012;
                const t = Math.min(transitionProgress, 1);
                const ease = t === 1 ? 1 : 1 - Math.pow(2, -10 * t);

                const targetPos = new THREE.Vector3(0, 80, 450);
                camera.position.lerp(targetPos, 0.03 + ease * 0.04);
                camera.lookAt(0, 0, 0);
                
                const scale = 0.01 + ease * 0.99;
                galaxyGroup.scale.set(scale, scale, scale);

                sky.material.uniforms.topColor.value.lerp(new THREE.Color(0x1a0a40), 0.02);
                sky.material.uniforms.bottomColor.value.lerp(new THREE.Color(0x0a0520), 0.02);

                if (bloomPass.strength > 2.2) bloomPass.strength -= 0.03;

                if (t >= 1 && camera.position.z > 400) {
                    state = 'SPACE';
                    transitionProgress = 0;
                    document.getElementById('backHint').style.opacity = 1;
                    bloomPass.strength = 2.2;
                }

            } else if (state === 'SPACE') {
                galaxyTime += 0.016;
                gu.time.value = time * Math.PI * 0.3;
                
                // Camera breathing in space
                const breathX = Math.sin(time * 0.3) * 2;
                const breathY = Math.cos(time * 0.4) * 1.5;
                camera.position.x += (breathX - camera.position.x + camera.position.x * 0.002) * 0.02;
                camera.position.y += (80 + breathY - camera.position.y) * 0.02;
                
                // Galaxy rotation with mouse
                galaxyGroup.rotation.y += 0.002;
                galaxyGroup.rotation.x += (mouseY * 0.6 - galaxyGroup.rotation.x) * 0.04;
                galaxyGroup.rotation.z += (mouseX * 0.4 - galaxyGroup.rotation.z) * 0.04;

                galaxyPoints.rotation.y -= 0.001;

               // Cards animation
cards.forEach((c, i) => {
    if (galaxyTime > c.userData.fadeDelay) {
        c.userData.fadeProgress = Math.min(c.userData.fadeProgress + 0.015, 1);
        const fadeEase = c.userData.fadeProgress < 0.5 
            ? 2 * c.userData.fadeProgress * c.userData.fadeProgress 
            : 1 - Math.pow(-2 * c.userData.fadeProgress + 2, 2) / 2;  // ‚Üê TH√äM PH·∫¶N N√ÄY
        
        c.material.opacity = fadeEase * 0.95;
    }
    
    c.userData.angle += c.userData.speed;
    const r = c.userData.radius;
    const depthWave = Math.sin(c.userData.angle * 1.8) * 15;
    
    c.position.x = Math.cos(c.userData.angle) * r;
    c.position.z = Math.sin(c.userData.angle) * r + depthWave;
    c.position.y = c.userData.baseY + Math.sin(time * 1.5 + i) * 12;
    
    
            // Core glow pulse
            coreGlow.material.opacity = 0.8 + Math.sin(time * 2) * 0.2;
            coreLight.intensity = 2.8 + Math.sin(time * 1.5) * 0.4;
        }

        composer.render();
    }

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        composer.setSize(window.innerWidth, window.innerHeight);
    });

    animate();

</script>
