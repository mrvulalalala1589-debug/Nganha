<!DOCTYPE html>
<html lang="vi">
<head>
<meta charset="UTF-8">
<title>Galaxy 3D Hand Gallery</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

<style>
html,body{
  margin:0;
  padding:0;
  overflow:hidden;
  background:black;
  font-family:Arial,sans-serif;
}
#status{
  position:fixed;
  top:12px;
  left:50%;
  transform:translateX(-50%);
  z-index:10;
  color:#0ff;
  background:rgba(0,0,0,.5);
  padding:8px 18px;
  border-radius:20px;
  font-size:14px;
}
</style>
</head>

<body>
<div id="status">ðŸŒŒ Galaxy 3D Ä‘ang khá»Ÿi Ä‘á»™ngâ€¦</div>

<script>
/* =====================================================
   CONFIG
===================================================== */
const IMAGE_COUNT = 10;
const IMAGE_RADIUS = 40;
const STAR_COUNT = 2000;

/* =====================================================
   STATE
===================================================== */
let scene, camera, renderer;
let galaxyGroup, starGroup;
let photoMeshes = [];
let targetRotation = 0;
let targetZoom = 80;
let currentZoom = 80;

let lastX = null;
let usingHand = false;
let lastGestureTime = 0;

/* =====================================================
   INIT 3D
===================================================== */
init();
animate();

function init(){
  scene = new THREE.Scene();
  scene.fog = new THREE.FogExp2(0x000000,0.002);

  camera = new THREE.PerspectiveCamera(60,window.innerWidth/window.innerHeight,0.1,1000);
  camera.position.z = currentZoom;

  renderer = new THREE.WebGLRenderer({antialias:true});
  renderer.setSize(window.innerWidth,window.innerHeight);
  renderer.setPixelRatio(Math.min(2,window.devicePixelRatio));
  document.body.appendChild(renderer.domElement);

  galaxyGroup = new THREE.Group();
  scene.add(galaxyGroup);

  createStars();
  createPhotos();

  window.addEventListener('resize',onResize);
  setupMouseTouch();
  setupHandTracking();
}

/* =====================================================
   STARS
===================================================== */
function createStars(){
  const geo = new THREE.BufferGeometry();
  const pos = [];

  for(let i=0;i<STAR_COUNT;i++){
    const r = Math.random()*200;
    const theta = Math.random()*Math.PI*2;
    const phi = Math.acos(2*Math.random()-1);

    pos.push(
      r*Math.sin(phi)*Math.cos(theta),
      r*Math.sin(phi)*Math.sin(theta),
      r*Math.cos(phi)
    );
  }

  geo.setAttribute('position',new THREE.Float32BufferAttribute(pos,3));
  const mat = new THREE.PointsMaterial({
    color:0xffffff,
    size:1,
    transparent:true
  });

  starGroup = new THREE.Points(geo,mat);
  scene.add(starGroup);
}

/* =====================================================
   PHOTOS IN SPIRAL
===================================================== */
function createPhotos(){
  const loader = new THREE.TextureLoader();
  const geo = new THREE.PlaneGeometry(10,10);

  for(let i=0;i<IMAGE_COUNT;i++){
    const tex = loader.load(`space${i+1}.png`);
    const mat = new THREE.MeshBasicMaterial({
      map:tex,
      transparent:true,
      side:THREE.DoubleSide
    });

    const mesh = new THREE.Mesh(geo,mat);

    const angle = i/IMAGE_COUNT * Math.PI*2;
    const radius = IMAGE_RADIUS + Math.random()*10;
    const y = (Math.random()-0.5)*10;

    mesh.position.set(
      Math.cos(angle)*radius,
      y,
      Math.sin(angle)*radius
    );

    mesh.lookAt(0,0,0);
    galaxyGroup.add(mesh);
    photoMeshes.push(mesh);
  }
}

/* =====================================================
   INPUT â€“ MOUSE & TOUCH
===================================================== */
function setupMouseTouch(){
  window.addEventListener('mousedown',e=>{
    usingHand=false;
    lastX=e.clientX;
    status("ðŸ–±ï¸ KÃ©o chuá»™t Ä‘á»ƒ xoay â€“ cuá»™n Ä‘á»ƒ zoom");
  });

  window.addEventListener('mousemove',e=>{
    if(lastX!==null){
      targetRotation += (e.clientX-lastX)*0.002;
      lastX=e.clientX;
    }
  });

  window.addEventListener('mouseup',()=>lastX=null);

  window.addEventListener('wheel',e=>{
    targetZoom += e.deltaY*0.05;
    targetZoom = THREE.MathUtils.clamp(targetZoom,30,150);
  });

  window.addEventListener('touchstart',e=>{
    usingHand=false;
    lastX=e.touches[0].clientX;
    status("ðŸ‘† Vuá»‘t Ä‘á»ƒ xoay â€“ pinch Ä‘á»ƒ zoom");
  });

  window.addEventListener('touchmove',e=>{
    const x=e.touches[0].clientX;
    targetRotation += (x-lastX)*0.003;
    lastX=x;
  });

  window.addEventListener('touchend',()=>lastX=null);
}

/* =====================================================
   HAND TRACKING
===================================================== */
function setupHandTracking(){
  const video=document.createElement('video');
  const hands=new Hands({
    locateFile:f=>`https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}`
  });

  hands.setOptions({
    maxNumHands:1,
    modelComplexity:1,
    minDetectionConfidence:0.6,
    minTrackingConfidence:0.6
  });

  hands.onResults(res=>{
    if(!res.multiHandLandmarks.length) return;
    usingHand=true;

    const lm=res.multiHandLandmarks[0];
    const x=lm[8].x-0.5;
    targetRotation += x*0.05;

    const pinch=Math.hypot(
      lm[4].x-lm[8].x,
      lm[4].y-lm[8].y
    );

    if(pinch<0.05){
      targetZoom-=1;
    }else{
      targetZoom+=0.5;
    }

    targetZoom=THREE.MathUtils.clamp(targetZoom,30,150);
    status("âœ‹ Xoay tay Ä‘á»ƒ xoay â€“ pinch Ä‘á»ƒ zoom");
  });

  try{
    const cam=new Camera(video,{
      onFrame:async()=>await hands.send({image:video}),
      width:640,height:480
    });
    cam.start();
  }catch(e){
    status("ðŸ‘† KhÃ´ng cÃ³ camera â€“ dÃ¹ng chuá»™t / vuá»‘t");
  }
}

/* =====================================================
   ANIMATE
===================================================== */
function animate(){
  requestAnimationFrame(animate);

  galaxyGroup.rotation.y += (targetRotation-galaxyGroup.rotation.y)*0.05;
  currentZoom += (targetZoom-currentZoom)*0.1;
  camera.position.z=currentZoom;

  starGroup.rotation.y += 0.0005;
  renderer.render(scene,camera);
}

/* =====================================================
   UTILS
===================================================== */
function onResize(){
  camera.aspect=window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth,window.innerHeight);
}

function status(t){
  document.getElementById("status").innerText=t;
}
</script>
</body>
</html>
