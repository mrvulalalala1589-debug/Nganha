<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Stellar Portrait - Grand Luxury Edition</title>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r159/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Playfair+Display:wght@400;700;900&family=Montserrat:wght@300;400;600&display=swap');
        
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            margin: 0;
            overflow: hidden;
            background: radial-gradient(ellipse at center, #1a1a2e 0%, #0a0a0f 100%);
            font-family: 'Montserrat', sans-serif;
        }
        
        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: fixed;
            top: 0;
            left: 0;
        }
        
        /* Splash Screen */
        #splash {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100vh;
            background: radial-gradient(ellipse at center, #1a1a2e 0%, #0a0a0f 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 9999;
            transition: opacity 1.5s ease;
        }
        
        #splash.hidden {
            opacity: 0;
            pointer-events: none;
        }
        
        .splash-title {
            font-family: 'Playfair Display', serif;
            font-size: clamp(3rem, 8vw, 7rem);
            font-weight: 900;
            background: linear-gradient(135deg, #d4af37 0%, #ffd700 50%, #d4af37 100%);
            background-size: 200% 200%;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: shimmer 3s ease-in-out infinite;
            letter-spacing: 0.05em;
            margin-bottom: 1rem;
        }
        
        @keyframes shimmer {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }
        
        .splash-subtitle {
            font-size: clamp(1rem, 2.5vw, 1.5rem);
            font-weight: 300;
            color: rgba(212, 175, 55, 0.8);
            letter-spacing: 0.3em;
            text-transform: uppercase;
            margin-bottom: 3rem;
        }
        
        #start-button {
            padding: 20px 60px;
            font-size: 1.2rem;
            font-weight: 600;
            color: #0a0a0f;
            background: linear-gradient(135deg, #d4af37 0%, #ffd700 100%);
            border: none;
            border-radius: 50px;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 0.2em;
            transition: all 0.4s ease;
            box-shadow: 0 10px 40px rgba(212, 175, 55, 0.4);
        }
        
        #start-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 15px 50px rgba(212, 175, 55, 0.6);
        }
        
        /* UI Layer */
        #ui-layer {
            position: fixed;
            bottom: 40px;
            width: 100%;
            text-align: center;
            z-index: 100;
            pointer-events: none;
            display: none;
        }
        
        #status-badge {
            display: inline-block;
            background: rgba(10, 10, 15, 0.9);
            border: 2px solid rgba(212, 175, 55, 0.6);
            color: #d4af37;
            padding: 15px 50px;
            border-radius: 50px;
            font-family: 'Playfair Display', serif;
            font-size: 1.3rem;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.2em;
            box-shadow: 0 0 40px rgba(212, 175, 55, 0.3);
            animation: statusPulse 2s ease-in-out infinite;
        }
        
        @keyframes statusPulse {
            0%, 100% { box-shadow: 0 0 40px rgba(212, 175, 55, 0.3); }
            50% { box-shadow: 0 0 60px rgba(212, 175, 55, 0.6); }
        }
        
        .gesture-guide {
            margin-top: 20px;
            color: rgba(212, 175, 55, 0.7);
            font-size: 0.9rem;
            letter-spacing: 0.1em;
        }
        
        .gesture-guide span {
            color: #d4af37;
            font-weight: 600;
        }
        
        /* Camera */
        #camera-container {
            position: fixed;
            top: 30px;
            right: 30px;
            width: 180px;
            height: 135px;
            z-index: 200;
            display: none;
        }
        
        #camera-preview {
            width: 100%;
            height: 100%;
            border: 3px solid rgba(212, 175, 55, 0.6);
            border-radius: 15px;
            transform: scaleX(-1);
            box-shadow: 0 0 40px rgba(212, 175, 55, 0.4);
            background: rgba(10, 10, 15, 0.9);
        }
        
        #camera-status {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(10, 10, 15, 0.9);
            color: #d4af37;
            padding: 5px 15px;
            border-radius: 20px;
            font-size: 0.75rem;
            border: 1px solid rgba(212, 175, 55, 0.5);
        }
        
        .input_video { display: none; }
        
        #loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #d4af37;
            font-size: 1.5rem;
            font-family: 'Playfair Display', serif;
            z-index: 9998;
            display: none;
            text-align: center;
        }
        
        #loading-bar {
            width: 300px;
            height: 4px;
            background: rgba(212, 175, 55, 0.2);
            border-radius: 2px;
            margin-top: 20px;
            overflow: hidden;
        }
        
        #loading-fill {
            height: 100%;
            background: linear-gradient(90deg, #d4af37, #ffd700);
            width: 0%;
            transition: width 0.3s ease;
            box-shadow: 0 0 10px rgba(212, 175, 55, 0.8);
        }
    </style>
</head>
<body>
    <div id="splash">
        <div class="splash-title">STELLAR PORTRAIT</div>
        <div class="splash-subtitle">Grand Luxury Edition</div>
        <button id="start-button" onclick="startExperience()">Enter Experience</button>
    </div>
    
    <div id="loading">
        <div>Creating Stellar Portrait...</div>
        <div id="loading-bar">
            <div id="loading-fill"></div>
        </div>
    </div>
    
    <div id="camera-container">
        <canvas id="camera-preview"></canvas>
        <div id="camera-status">Ready</div>
    </div>
    
    <div id="ui-layer">
        <div id="status-badge">âœ¨ PORTRAIT FORMED âœ¨</div>
        <div class="gesture-guide">
            <span>OPEN HAND</span> Unleash Memories &nbsp;|&nbsp; 
            <span>CLOSE FIST</span> Reform Portrait &nbsp;|&nbsp;
            <span>MOVE HAND</span> Navigate Photos
        </div>
    </div>
    
    <div id="canvas-container"></div>
    <video class="input_video"></video>

    <script>
        // ==========================================
        // CONFIGURATION
        // ==========================================
        const CONFIG = {
            particleCount: 20000,
            chaosRadius: 100,
            transitionSpeed: 0.04,
            photoOrbitRadius: 40,
            photoCount: 10,
            rotationSpeed: 0.0005
        };

        // Photo files
        const PHOTO_FILES = [];
        for(let i = 1; i <= CONFIG.photoCount; i++) {
            PHOTO_FILES.push(`./image${i}.png`);
        }

        // ==========================================
        // GLOBALS
        // ==========================================
        let scene, camera, renderer;
        let particleSystem, particles;
        let photoMeshes = [];
        let portraitGeometry = [];
        
        let state = 'FORMED'; // FORMED, CHAOS, PHOTO
        let progress = 1.0; // 0 = chaos, 1 = formed
        let targetProgress = 1.0;
        
        let handX = 0.5;
        let handY = 0.5;
        let handZ = 0.5;
        let selectedPhotoIndex = 0;

        // ==========================================
        // PORTRAIT DATA PROCESSING
        // ==========================================
        async function loadAndProcessPortrait() {
            return new Promise((resolve) => {
                const img = new Image();
                img.onload = () => {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    
                    // Process size
                    const processWidth = 220;
                    const processHeight = Math.floor((img.height / img.width) * processWidth);
                    canvas.width = processWidth;
                    canvas.height = processHeight;
                    
                    ctx.drawImage(img, 0, 0, processWidth, processHeight);
                    const pixels = ctx.getImageData(0, 0, processWidth, processHeight).data;
                    
                    const points = [];
                    const portraitHeight = Math.floor(processHeight * 0.75);
                    
                    for(let y = 0; y < portraitHeight; y++) {
                        for(let x = 0; x < processWidth; x++) {
                            const idx = (y * processWidth + x) * 4;
                            const r = pixels[idx];
                            const g = pixels[idx + 1];
                            const b = pixels[idx + 2];
                            const brightness = (r + g + b) / (3 * 255);
                            
                            // Center-focused sampling
                            const cx = processWidth / 2;
                            const cy = portraitHeight * 0.35;
                            const dist = Math.sqrt(Math.pow(x - cx, 2) + Math.pow(y - cy, 2));
                            const maxDist = Math.min(processWidth, portraitHeight) / 2;
                            const normalizedDist = dist / maxDist;
                            
                            let sampleRate;
                            if(normalizedDist < 0.3) sampleRate = 2;
                            else if(normalizedDist < 0.6) sampleRate = 3;
                            else sampleRate = 5;
                            
                            if(x % sampleRate === 0 && y % sampleRate === 0) {
                                const nx = (x / processWidth) * 2 - 1;
                                const ny = -(y / portraitHeight) * 2 + 1;
                                const nz = (brightness - 0.5) * 0.5;
                                
                                points.push({
                                    x: nx * 35,
                                    y: ny * 45,
                                    z: nz * 25,
                                    brightness: brightness
                                });
                            }
                        }
                    }
                    
                    resolve(points);
                };
                
                // Use uploaded portrait (4.jpg)
                img.src = './4.jpg';
            });
        }

        // ==========================================
        // 3D SCENE SETUP
        // ==========================================
        function init3D() {
            const container = document.getElementById('canvas-container');
            
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x0a0a0f, 0.0015);
            
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 5, 130);
            
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            container.appendChild(renderer.domElement);
            
            createParticleSystem();
            createPhotos();
            createLights();
            animate();
        }

        function createParticleSystem() {
            const positions = [];
            const colors = [];
            const sizes = [];
            const chaosPositions = [];
            const targetPositions = [];
            
            for(let i = 0; i < CONFIG.particleCount; i++) {
                // Target: Portrait
                const pointIndex = Math.floor(Math.random() * portraitGeometry.length);
                const point = portraitGeometry[pointIndex];
                
                const variation = 2.5;
                const tx = point.x + (Math.random() - 0.5) * variation;
                const ty = point.y + (Math.random() - 0.5) * variation;
                const tz = point.z + (Math.random() - 0.5) * variation;
                
                targetPositions.push(tx, ty, tz);
                
                // Chaos: Sphere
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                const radius = Math.cbrt(Math.random()) * CONFIG.chaosRadius;
                
                const cx = radius * Math.sin(phi) * Math.cos(theta);
                const cy = radius * Math.sin(phi) * Math.sin(theta);
                const cz = radius * Math.cos(phi);
                
                chaosPositions.push(cx, cy, cz);
                positions.push(tx, ty, tz);
                
                // Golden color gradient
                const brightness = point.brightness;
                const gold = 0.65 + brightness * 0.35;
                colors.push(gold, gold * 0.75, gold * 0.2);
                
                sizes.push(0.4 + Math.random() * 1.2);
            }
            
            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            geometry.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));
            geometry.userData = { chaos: chaosPositions, target: targetPositions };
            
            const material = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 },
                    progress: { value: progress }
                },
                vertexShader: `
                    attribute float size;
                    attribute vec3 color;
                    varying vec3 vColor;
                    uniform float time;
                    uniform float progress;
                    
                    void main() {
                        vColor = color;
                        vec3 pos = position;
                        
                        float chaos = 1.0 - progress;
                        pos.y += sin(time * 0.5 + position.x * 0.1) * 1.0 * chaos;
                        pos.x += cos(time * 0.5 + position.y * 0.1) * 1.0 * chaos;
                        
                        vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
                        float pulse = 1.0 + sin(time * 2.0 + length(position) * 0.05) * 0.3 * chaos;
                        gl_PointSize = size * pulse * (300.0 / -mvPosition.z);
                        gl_Position = projectionMatrix * mvPosition;
                    }
                `,
                fragmentShader: `
                    varying vec3 vColor;
                    
                    void main() {
                        vec2 center = gl_PointCoord - 0.5;
                        float dist = length(center);
                        if(dist > 0.5) discard;
                        
                        float alpha = 1.0 - smoothstep(0.0, 0.5, dist);
                        alpha = pow(alpha, 1.2);
                        
                        vec3 glow = vColor * (1.0 + alpha * 0.8);
                        gl_FragColor = vec4(glow, alpha);
                    }
                `,
                transparent: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false,
                vertexColors: true
            });
            
            particleSystem = new THREE.Points(geometry, material);
            scene.add(particleSystem);
            particles = geometry;
        }

        function createPhotos() {
            const loader = new THREE.TextureLoader();
            const photoGeo = new THREE.PlaneGeometry(14, 14);
            const borderGeo = new THREE.PlaneGeometry(15, 15);
            const borderMat = new THREE.MeshBasicMaterial({ 
                color: 0xd4af37,
                side: THREE.DoubleSide
            });
            
            for(let i = 0; i < CONFIG.photoCount; i++) {
                const mat = new THREE.MeshBasicMaterial({
                    color: 0xffffff,
                    side: THREE.DoubleSide,
                    transparent: true
                });
                
                loader.load(PHOTO_FILES[i], (texture) => {
                    mat.map = texture;
                    mat.needsUpdate = true;
                });
                
                const mesh = new THREE.Mesh(photoGeo, mat);
                const border = new THREE.Mesh(borderGeo, borderMat);
                border.position.z = -0.1;
                mesh.add(border);
                
                mesh.visible = false;
                mesh.scale.set(0, 0, 0);
                scene.add(mesh);
                photoMeshes.push(mesh);
            }
        }

        function createLights() {
            const ambient = new THREE.AmbientLight(0xffd700, 0.4);
            scene.add(ambient);
            
            const point1 = new THREE.PointLight(0xffd700, 1.5, 300);
            point1.position.set(60, 60, 60);
            scene.add(point1);
            
            const point2 = new THREE.PointLight(0xd4af37, 1.2, 300);
            point2.position.set(-60, -40, 50);
            scene.add(point2);
        }

        // ==========================================
        // ANIMATION LOOP
        // ==========================================
        function animate() {
            requestAnimationFrame(animate);
            
            const time = Date.now() * 0.001;
            progress += (targetProgress - progress) * CONFIG.transitionSpeed;
            
            if(particleSystem) {
                particleSystem.material.uniforms.time.value = time;
                particleSystem.material.uniforms.progress.value = progress;
                
                const positions = particles.attributes.position.array;
                const chaosPos = particles.userData.chaos;
                const targetPos = particles.userData.target;
                
                for(let i = 0; i < positions.length; i += 3) {
                    positions[i] = chaosPos[i] + (targetPos[i] - chaosPos[i]) * progress;
                    positions[i + 1] = chaosPos[i + 1] + (targetPos[i + 1] - chaosPos[i + 1]) * progress;
                    positions[i + 2] = chaosPos[i + 2] + (targetPos[i + 2] - chaosPos[i + 2]) * progress;
                }
                
                particles.attributes.position.needsUpdate = true;
                
                if(state === 'FORMED') {
                    particleSystem.rotation.y += CONFIG.rotationSpeed;
                }
            }
            
            // Photo animations
            if(state === 'CHAOS') {
                animatePhotosOrbit(time);
            } else if(state === 'PHOTO') {
                animatePhotoView();
            } else {
                hidePhotos();
            }
            
            renderer.render(scene, camera);
        }

        function animatePhotosOrbit(time) {
            const baseAngle = time * 0.15;
            const angleStep = (Math.PI * 2) / CONFIG.photoCount;
            
            let closestIndex = 0;
            let minDist = 999;
            
            photoMeshes.forEach((mesh, i) => {
                mesh.visible = true;
                
                const angle = baseAngle + i * angleStep;
                const x = Math.sin(angle) * CONFIG.photoOrbitRadius;
                const z = Math.cos(angle) * CONFIG.photoOrbitRadius;
                const y = Math.sin(time * 0.4 + i) * 4;
                
                mesh.position.lerp(new THREE.Vector3(x, y, z), 0.08);
                mesh.lookAt(camera.position);
                
                const targetScale = (z > 0) ? 1.4 : 0.9;
                mesh.scale.lerp(new THREE.Vector3(targetScale, targetScale, targetScale), 0.08);
                
                const dist = Math.abs(angle - handX * Math.PI * 2);
                if(dist < minDist) {
                    minDist = dist;
                    closestIndex = i;
                }
            });
            
            selectedPhotoIndex = closestIndex;
        }

        function animatePhotoView() {
            photoMeshes.forEach((mesh, i) => {
                if(i === selectedPhotoIndex) {
                    mesh.visible = true;
                    const targetZ = 70 + handZ * 30;
                    mesh.position.lerp(new THREE.Vector3(0, 0, targetZ), 0.1);
                    
                    const targetScale = 4 + handZ * 2;
                    mesh.scale.lerp(new THREE.Vector3(targetScale, targetScale, targetScale), 0.1);
                    mesh.lookAt(camera.position);
                } else {
                    mesh.scale.lerp(new THREE.Vector3(0, 0, 0), 0.1);
                    if(mesh.scale.x < 0.01) mesh.visible = false;
                }
            });
        }

        function hidePhotos() {
            photoMeshes.forEach(mesh => {
                mesh.scale.lerp(new THREE.Vector3(0, 0, 0), 0.1);
                if(mesh.scale.x < 0.01) mesh.visible = false;
            });
        }

        // ==========================================
        // STATE CONTROL
        // ==========================================
        function setState(newState) {
            state = newState;
            
            if(state === 'FORMED') {
                targetProgress = 1.0;
                document.getElementById('status-badge').innerHTML = 'âœ¨ PORTRAIT FORMED âœ¨';
            } else if(state === 'CHAOS') {
                targetProgress = 0.0;
                document.getElementById('status-badge').innerHTML = 'ðŸ’« MEMORIES UNLEASHED ðŸ’«';
            } else if(state === 'PHOTO') {
                targetProgress = 0.3;
                document.getElementById('status-badge').innerHTML = `ðŸ“¸ PHOTO ${selectedPhotoIndex + 1}/${CONFIG.photoCount} ðŸ“¸`;
            }
        }

        // ==========================================
        // HAND TRACKING
        // ==========================================
        function startHandTracking() {
            const video = document.getElementsByClassName('input_video')[0];
            const canvas = document.getElementById('camera-preview');
            const ctx = canvas.getContext('2d');
            const statusDiv = document.getElementById('camera-status');
            
            const hands = new Hands({
                locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
            });
            
            hands.setOptions({
                maxNumHands: 1,
                modelComplexity: 0,
                minDetectionConfidence: 0.5,
                minTrackingConfidence: 0.5
            });
            
            let frameCnt = 0;
            
            hands.onResults(results => {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.drawImage(results.image, 0, 0, canvas.width, canvas.height);
                
                if(results.multiHandLandmarks.length > 0) {
                    const lm = results.multiHandLandmarks[0];
                    drawHandSkeleton(ctx, lm, canvas.width, canvas.height);
                    
                    // Hand position
                    handX = lm[9].x;
                    handY = lm[9].y;
                    handZ = 1 - lm[9].z;
                    
                    // Gesture detection
                    const tips = [8, 12, 16, 20];
                    const wrist = lm[0];
                    let openDist = 0;
                    tips.forEach(i => {
                        openDist += Math.hypot(lm[i].x - wrist.x, lm[i].y - wrist.y);
                    });
                    const avgDist = openDist / 4;
                    
                    if(avgDist < 0.25) {
                        setState('FORMED');
                        statusDiv.textContent = 'âœŠ FORMED';
                    } else if(avgDist > 0.45) {
                        setState('CHAOS');
                        statusDiv.textContent = 'ðŸ– UNLEASHED';
                    } else {
                        setState('PHOTO');
                        statusDiv.textContent = `ðŸ“¸ PHOTO ${selectedPhotoIndex + 1}`;
                    }
                    
                    statusDiv.style.color = '#d4af37';
                } else {
                    statusDiv.textContent = 'No hand';
                    statusDiv.style.color = '#999';
                }
            });
            
            const cameraUtils = new Camera(video, {
                onFrame: async () => {
                    frameCnt++;
                    if(frameCnt % 2 !== 0) return;
                    await hands.send({ image: video });
                },
                width: 640,
                height: 480
            });
            
            cameraUtils.start();
        }

        function drawHandSkeleton(ctx, lm, w, h) {
            const connections = [
                [0,1],[1,2],[2,3],[3,4],
                [0,5],[5,6],[6,7],[7,8],
                [0,9],[9,10],[10,11],[11,12],
                [0,13],[13,14],[14,15],[15,16],
                [0,17],[17,18],[18,19],[19,20],
                [5,9],[9,13],[13,17]
            ];
            
            ctx.strokeStyle = 'rgba(212, 175, 55, 0.8)';
            ctx.lineWidth = 2;
            
            connections.forEach(([s, e]) => {
                ctx.beginPath();
                ctx.moveTo(lm[s].x * w, lm[s].y * h);
                ctx.lineTo(lm[e].x * w, lm[e].y * h);
                ctx.stroke();
            });
            
            lm.forEach((l, i) => {
                ctx.fillStyle = [0,4,8,12,16,20].includes(i) ? '#ffd700' : '#d4af37';
                ctx.beginPath();
                ctx.arc(l.x * w, l.y * h, 4, 0, Math.PI * 2);
                ctx.fill();
            });
        }

        // ==========================================
        // START
        // ==========================================
        async function startExperience() {
            document.getElementById('splash').classList.add('hidden');
            document.getElementById('loading').style.display = 'block';
            
            // Simulate loading
            let loadProgress = 0;
            const loadInterval = setInterval(() => {
                loadProgress += 10;
                document.getElementById('loading-fill').style.width = loadProgress + '%';
                
                if(loadProgress >= 100) {
                    clearInterval(loadInterval);
                    setTimeout(() => {
                        document.getElementById('loading').style.display = 'none';
                        document.getElementById('ui-layer').style.display = 'block';
                        document.getElementById('camera-container').style.display = 'block';
                    }, 300);
                }
            }, 100);
            
            // Load portrait
            portraitGeometry = await loadAndProcessPortrait();
            console.log(`Portrait: ${portraitGeometry.length} points`);
            
            // Init 3D
            init3D();
            startHandTracking();
        }

        // ==========================================
        // CONTROLS
        // ==========================================
        document.addEventListener('keydown', (e) => {
            if(e.key === ' ') {
                e.preventDefault();
                if(state === 'FORMED') setState('CHAOS');
                else setState('FORMED');
            } else if(e.key === 'ArrowLeft') {
                selectedPhotoIndex = (selectedPhotoIndex - 1 + CONFIG.photoCount) % CONFIG.photoCount;
            } else if(e.key === 'ArrowRight') {
                selectedPhotoIndex = (selectedPhotoIndex + 1) % CONFIG.photoCount;
            }
        });

        window.addEventListener('resize', () => {
            if(camera && renderer) {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            }
        });
    </script>
</body>
</html>
